---
title: 尚品汇-电商购物-笔记
date: 2022-09-18 13:56:14
tags: vue2项目笔记
---

# day-01

## 1、脚手架使用

<!-- more -->

**2**: vue init webpack 项目的名字
**3**：vue create 项目名称

**脚手架目录:public + assets文件夹区别**

node_modules:放置项目依赖的地方

public:一般放置一些共用的静态资源，打包上线的时候，public文件夹里面资源原封不动打包到dist文件夹里面

src：程序员源代码文件夹

  -----assets文件夹：经常放置一些静态资源（图片），assets文件夹里面资源webpack会进行打包为一个模块（js文件夹里面）

  -----components文件夹:一般放置非路由组件（或者项目共用的组件）
        App.vue 唯一的根组件
        main.js 入口文件【程序最先执行的文件】

  babel.config.js:babel配置文件
  package.json：看到项目描述、项目依赖、项目运行指令
  README.md:项目说明文件

## 2、脚手架下载下来的项目稍微配置一下

### 1浏览器自动打开

​        在package.json文件中
​        "scripts": {
​         "serve": "vue-cli-service serve --open",
​          "build": "vue-cli-service build",
​          "lint": "vue-cli-service lint"
​        },

### 2关闭eslint校验工具

创建vue.config.js文件：需要对外暴露
module.exports = {
   lintOnSave:false,
}

### 3 src文件夹的别名的设置

因为项目大的时候src（源代码文件夹）：里面目录会很多，找文件不方便，设置src文件夹的别名的好处，找文件会方便一些
创建jsconfig.json文件
{
    "compilerOptions": {
        "baseUrl": "./",
        "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },
    "exclude": [
        "node_modules",
        "dist"
    ]
}

## 3、路由的配置

vue-router
路由分为KV

前端路由:
K即为URL（网络资源定位符）
V即为相应的路由组件

## 4、v-show与v-if区别?

v-show:通过样式display控制
v-if：通过元素上树与下树进行操作

面试题:开发项目的时候，优化手段有哪些?
1:v-show|v-if
2:按需加载

## 5、路由跳转方式有几种？

比如 A -> B

声明式导航： router-link (务必要写 to = "/path")，可以实现路由的跳转

```html
<router-link to="/login">登录</router-link>
<router-link to="/register" class="register">免费注册</router-link>
```

编程式导航：利用的是组件实例的 $router.push | replace 方法，可以实现路由的跳转。（可以书写一些自己的业务，然后进行跳转）

```html
<button class="sui-btn btn-xlarge btn-danger" type="button" @click="goSearch">
    搜索
</button>

goSearch(){
      // 第一种
      // this.$router.push('/search/' + this.keyword + '/?k=' + this.keyword.toUpperCase());
      // 第二种
      // this.$router.push(`/search/${this.keyword}/?k=${this.keyword.toUpperCase()}`)
      // 第三种
      this.$router.push({name: 'search', params:{keyword: this.keyword}, query: {k: this.keyword.toUpperCase()}}, ()=>{}, (err)=>{});
      // this.$router.push({name: 'search', query: {k: this.keyword.toUpperCase()}})
      // this.$router.push({name: 'search', params:{keyword: ''||undefined}, query: {k: this.keyword.toUpperCase()}})
}
```



## 6、路由传参

### 1.路由传参，参数有几种写法？

params参数：属于路径当中的一部分，需要注意，在配置路由的时候，要设置占位符

query参数：不属于路径中的一部分，类似于ajax中的 queryString / home?k=v&k=v，不需要占位

```js
{
      path: '/search/:keyword',
      component: Search,
      meta:{show:true},
      // 路由的第三种传参
      name: 'search'
}

goSearch(){
    // 第一种
    // this.$router.push('/search/' + this.keyword + '/?k=' + this.keyword.toUpperCase());
    // 第二种
    // this.$router.push(`/search/${this.keyword}/?k=${this.keyword.toUpperCase()}`)
    // 第三种	  这里的name，对应的是 配置 router时的 name
    this.$router.push({name: 'search', params:{keyword: this.keyword}, query: {k: this.keyword.toUpperCase()}})
}
```

### 2.相关面试题

1.路由传递参数（对象写法）path是否可以结合params参数一起使用?

```js
答： 不可以，路由跳转传参的时候，对象的写法可以是 name、path 形式，但是需要注意的是，path这种写法不能与 params参数一起使用
this.$router.push({path: '/search', params:{keyword: this.keyword}, query: {k: this.keyword.toUpperCase()}})
```

2.如何指定params参数可传可不传? 

```js
答：如果路由要求传递params参数，但是就不传递参数，发现一件事情，URL会有问题，路径不对
如何指定 params 参数可传递可不传递呢？在配置路由的时候，在占位符后面加上一个 ? 【params参数可以传递或者不需要传递，正则表达式 ? 可有可无】

{
      path: '/search/:keyword',
      component: Search,
      meta:{show:true},
      // 路由的第三种传参
      name: 'search'
}
比如： 配置路由的时候，占位了（params参数），但是路由跳转的时候就不传递。
路径会出现问题
http://localhost:8080/#/?k=qwe
http://localhost:8080/#/search?k=qwe
this.$router.push({path: '/search', query: {k: this.keyword.toUpperCase()}})

解决：在 path的 params后面 加一个 ?
{
      path: '/search/:keyword?',
      component: Search,
      meta:{show:true},
      // 路由的第三种传参
      name: 'search'
}
```

3.params参数可以传递也可以不传递，但是如果传递是空串，如何解决？

```js
答：如果不处理，还是会出现URL的问题，URL错误，使用 ||undefined 来解决这种问题

this.$router.push({name: 'search', params:{keyword: ''||undefined}, query: {k: this.keyword.toUpperCase()}})
```

4.路由组件能不能传递props数据?

```js
答：是可以的，有三种写法

1. 布尔值写法  --------   只能传递params参数
// 跳转
this.$router.push({name: 'search', params:{keyword: this.keyword}, query: {k: this.keyword.toUpperCase()}})
// 路由的配置
{
      path: '/search/:keyword',
      component: Search,
      meta:{show:true},
      // 路由的第三种传参
      name: 'search',
      // 路由组件能不能传递 props 数据？
      props: true
}
// Search组件
export default {
  name: 'Search',
  props:['keyword']
}

2.对象写法
// 路由的配置
{
      path: '/search/:keyword',
      component: Search,
      meta:{show:true},
      // 路由的第三种传参
      name: 'search',
      // 对象写法
      props:{
        a: 1, b: 2
      }
}
// Search组件
export default {
  name: 'Search',
  props:['keyword', 'a', 'b']
}

3.函数写法 ------  最常用
// 路由的配置
{
      path: '/search/:keyword',
      component: Search,
      meta:{show:true},
      // 路由的第三种传参
      name: 'search',
      // 函数写法，可以通过params参数、query参数，通过props传递给路由组件
      props: ($route) => {
        return {keyword: $route.params.keyword, k: $route.query.k}
      }
}
// Search组件
export default {
  name: 'Search',
  props:['keyword', 'a', 'b', 'k']
}
```



# day-02

## 1、编程式导航路由跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误?

-- 路由跳转有2种方式，声明式导航，编程式导航

-- 声明式是没有这种问题的，因为 vur-router 底层已经处理好了

```js
let res = this.$router.push({name: 'search', params:{keyword: this.keyword}, query: {k: this.keyword.toUpperCase()}})
console.log(res);

function push(){
    return new Promise((resolve, reject) => {
        
    })
}
```

**解决1、治标不治本：**

**将来在别的组件中push | replace，还是会有这样的错误。**

通过 push 方法传递相应的成功、失败的回调函数，可以捕获到当前错误，可以解决。

```js
this.$router.push({name: 'search', params:{keyword: this.keyword}, query: {k: this.keyword.toUpperCase()}}, ()=>{}, (err)=>{console.log(err);});
```

this：当前组件实例（Search）

this.$router属性：当前的这个属性，属性值 VueRouter类的一个实例，当在入口文件注册路由的时候，给组件实例添加$router | $route属性。

```js
push : VueRouter类的一个实例

function VueRouter(){}

VueRouer.propertype.push = function(){
    // 函数的上下文是 VueRouter 的一个实例
}

let $router = new VueRouer();

$router.push(xxx);
```

**解决2：重写原型的 push 、 replace**

```js
// 跳转的方法
this.$router.push({name: 'search', params:{keyword: this.keyword}, query: {k: this.keyword.toUpperCase()}}, ()=>{}, (err)=>{});


// 拷贝原来的 push 、 replace
let originPush = VueRouter.prototype.push;
let originReplace = VueRouter.prototype.replace;

// 重写 push  和 replace 方法
// 第一个参数： 往哪儿跳
VueRouter.prototype.push = function(location, resolve, reject){
  if(resolve && reject){
    originPush.call(this, location, resolve, reject);
  }else{
    originPush.call(this, location, () => {}, () => {});
  }
}
VueRouter.prototype.replace = function(location, resolve, reject){
  if(resolve && reject){
    originReplace.call(location, resolve, reject);
  }else{
    originReplace.call(location, ()=>{}, ()=>{});
  }
}
```

## 2、axios二次封装

XMLHttpRequest、fetch、JQ、axios6.1为什么需要进行二次封装axios?
请求拦截器、响应拦截器:请求拦截器，可以在发请求之前可以处理一些业务、响应拦截器，当服务器数据返回以后，可以处理一些事情

**解决跨域问题**： JSONP、代理、core

**requests.js**

```js
// 对 axios 进行 二次封装
import axios from 'axios';
// 引入 nprogress --- 进度条
import nProgress from 'nprogress';
// start：进度条开始   done：进度条结束
// 引入进度条的样式, 修改 nprogress中的 .bar 背景颜色 可以修改 进度条的颜色
import 'nprogress/nprogress.css'


// 1.利用axios对象的方法 create，去创建一个 axios 实例
const requests = axios.create({
  // 配置对象
  // 基础路径，发送请求的时候，路径当中会出现 api
  baseURL: '/api',
  // 请求超时时间
  timeout: 5000,
});

// 请求拦截器 --- 在发送请求之前做一些事情
requests.interceptors.request.use((config) => {
  // config: 配置对象，对象里面有一个属性很重要，headers请求头
  nProgress.start();
  return config;
});

// 响应拦截器 ---  在响应之后做一些事情
requests.interceptors.response.use((res) => {
  // 成功的回调函数：服务器响应数据回来以后，响应拦截器可以检测到，做一些事情
  nProgress.done();
  return res.data;
}, (error) => {
  // 响应失败的回调函数
  return Promise.reject(new Error('faile'));
});

// 向外暴露
export default requests;
```

**index.js**

```js
// 这个模块： API 进行统一管理
import requests from "./request";

// 三级联动接口
// /api/product/getBaseCategoryList   get   无参
export const reqCategoryList = () => {
  // 发请求   axios 发送请求的返回结果是 一个promise对象
  return requests({url: '/product/getBaseCategoryList', method: 'get'})
}
```

**配置代理 --- vue.condig.js  ---  相当于 webpack.config.js**

```js
module.exports = {
  // 关闭 eslint
  lintOnSave: false,
  // 代理跨域
  devServer: {
    proxy: {
      '/api': {
        target: 'http://gmall-h5-api.atguigu.cn',
        // pathRewrite: {'^/api': ''}
      }
    }
  }
}
```

**使用requests请求数据**

```js
// 测试
import {reqCategoryList} from '@/api'
reqCategoryList();
```



## 3、nprogress进度条的使用

```js
// 引入 nprogress --- 进度条
import nProgress from 'nprogress';
// start：进度条开始   done：进度条结束
// 引入进度条的样式, 修改 nprogress中的 .bar 背景颜色 可以修改 进度条的颜色
import 'nprogress/nprogress.css'
```

## 4、Vuex 状态管理库

**state**：存储数据。

**mutations**：修改 state的唯一手段

**actions**：处理action，可以书写自己的业务逻辑，也可以处理异步操作

**getters**：理解为计算属性，用于简化仓库数据，让组件获取仓库的数据更加方便

**modules**

#### 基本使用

main.js 注册store

```js
import Vue from 'vue'
import App from './App.vue'

// 引入仓库 vuex
import store from '@/store';

new Vue({
  render: h => h(App),
  // 注册路由
  router,
  // 注册仓库：组件实例的身上会多一个属性 $store 属性
  store
}).$mount('#app')
```



index.vue

```js
import {mapState} from 'vuex'

methods: {
    add(){
        this.$store.dispatch('add');
    },
        sub(){
            this.$store.dispatch('sub');
        }
},
computed:{
    ...mapState(['count'])
}
```

store.js

```js
import Vue from 'vue';
import Vuex from 'vuex';
// 需要使用一次插件
Vue.use(Vuex);

const state = {
  count: 1,
};
const mutations = {
  ADD(state){
    state.count++;
  }
};
const actions = {
  add({commit}){
    commit('ADD');
  },
  sub(){

  }
};
const getters = {};

// 对外暴露 Store类的一个实例
export default new Vuex.Store({
  state, mutations, actions, getters
});
```

## 5、Vuex 模块化

main.js 注册Store

```js
import Vue from 'vue'
import App from './App.vue'

// 引入仓库 vuex
import store from '@/store';

new Vue({
  render: h => h(App),
  // 注册路由
  router,
  // 注册仓库：组件实例的身上会多一个属性 $store 属性
  store
}).$mount('#app')
```

store  ->  Home  ->  index.js

```js
// home 模块的小仓库
const state = {a: 2};
const mutations = {};
const actions = {};
const getters = {};
export default {
  state, mutations, actions, getters
}
```

store  ->  Search->  index.js

```js
// search 模块的小仓库
const state = {b: 1};
const mutations = {};
const actions = {};
const getters = {};
export default {
  state, mutations, actions, getters
}
```

store -> index.js 总仓库

```js
import Vue from 'vue';
import Vuex from 'vuex';
// 需要使用一次插件
Vue.use(Vuex);

// 引入小仓库
import home from '@/store/Home'
import search from '@/store/Search'

// 对外暴露 Store类的一个实例
export default new Vuex.Store({
  modules: {
    home, 
    search
  }
});
```



# day-03

## 1、演示卡顿现象

正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么可能出现浏览器卡顿）

节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，吧频繁触发变为少量触发

防抖：前面的所有触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的书法，只会执行一次

## 2、重点！！！三级联动组件的路由跳转与传递参数

三级联动用户可以点击的:一级分类、二级分类、三级分类，当你点击的时候
Home模块跳转到Search模块，一级会把用户选中的产品（产品的名字、产品的ID)在路由跳转的时候，进行传递。

### **路由跳转:**

声明式导航:router-link；  	编程式导航:push|replace

### **三级联动:**

如果使用声明式导航router-link，可以实现路由的跳转与传递参数。但是需要注意，出现卡顿现象。

router-link: 是一个组件，当服务器的数据返回之后，循环出很多的router-link组件【创建组件实例的】1000+创建组件实例的时候，一瞬间创建1000+很耗内存，因此出现了卡顿现象。

如果使用编程式导航，就要绑定 1000+个 回调函数，也会耗内存。

### **最好的解决办法： 编程式导航 + 事件委派**

但是利用事件委派**存在一些问题**： 1：点击的一定是 a 标签么？  2：如何获取参数【一级菜单、二级菜单、三级菜单】？

事件委派：把全部子节点【h3、dt、dl、em】的时间委派给父亲结点

点击a标签的时候，才会进行路由的跳转【怎么确定点击的一定是a标签？】

存在**另一个问题**：即使确定是a标签，如何确定是 二级标签 还是 三级标签？

### **如何完成三级联动路由跳转？**

1、先分别给 a 标签添加自定义属性： :data-categoryName="c1.categoryName"，其余标签上是没有这个属性的，并且给一个 categoryXid 来判断是几级标签

```html
<div class="all-sort-list2"  @click="goSearch">
    <div
         class="item"
         v-for="(c1, index) in categoryList"
         :key="c1.categoryId"
         :class="{ cur: currentIndex == index }"
         >
        <h3 @mouseenter="changeIndex(index)">
            <a :data-categoryName="c1.categoryName" :data-category1Id="c1.categoryId">{{ c1.categoryName }}</a>
        </h3>
        <!-- 二级、三级分类 -->
        <div class="item-list clearfix" :style="{display: currentIndex == index ? 'block' : 'none'}">
            <div class="subitem">
                <dl
                    class="fore"
                    v-for="c2 in c1.categoryChild"
                    :key="c2.categoryId"
                    >
                    <dt>
                        <a :data-categoryName="c2.categoryName" :data-category2Id="c2.categoryId">{{ c2.categoryName }}</a>
                    </dt>
                    <dd>
                        <em v-for="c3 in c2.categoryChild" :key="c3.categoryId">
                            <a :data-categoryName="c3.categoryName" :data-category3Id="c3.categoryId">{{ c3.categoryName }}</a>
                        </em>
                    </dd>
                </dl>
            </div>
        </div>
    </div>
</div>
```

2、通过 event 参数，可以获取当前点击事件的信息，从而判断是否为a标签

let element = event.target

获取到发出当前这个事件的节点【h3、a、dt、dl】，需要带有 data-categoryname这样的结点【一定是a标签】

结点有一个属性：dataset属性，可以获取结点的自定义属性与属性值

```js
goSearch(e) {
    // 最好的解决办法： 编程式导航 + 事件委派
    // 利用事件委派存在一些问题： 1：点击的一定是 a 标签么？  2：如何获取参数【一级菜单、二级菜单、三级菜单】？
    let element = event.target; // 获取发出当前事件的结点
    let {categoryname, category1id, category2id, category3id} = element.dataset;  // 获取当前结点上的自定义属性
    // 如果存在categoryName这个属性，那么说明一定是 a 标签，需要跳转
    if(categoryname){
        // 整理路由跳转的参数
        let location = {name: 'search'};
        let query = {categoryname};
        if(category1id){
            query.category1id = category1id;
        }else if(category2id){
            query.category2id = category2id;
        }else{
            query.category3id = category3id;
        }
        // 整理完整的参数
        location.query = query;
        // 路由跳转
        this.$router.push(location);
    }
}
```

# day-04

## 1、开发Search模块中的TypeNav商品分类菜单（过渡动画效果)

过渡动画:前提组件|元素务必要有v-if|v-show指令才可以进行过渡动画

## 2、现在咱们的商品分类三级列表可以进行优化?

在App根组件当中发请求【根组件mounted】执行一次

## 3、合并params与query参数?

## 4、开发Home首页当中的ListContainer组件与Floor组件?

https://docschina.org/

但是这里需要知道一件事情:服务器返回的数据（接口）只有商品分类菜单分类数据，对于ListContainer组件与Floor组件数据服务器没有提供的。
mock数据（模拟）:如果你想mock数据，需要用到一个插件mockjs I

## 5、mockjs用法

1. 在项目中的src中创建一个文件夹 mock
2. 准备 json 数据（mock文件夹中创建JSON文件） -----  格式化一下，别留空格（不然跑不起来）
3. 把mock数据需要的图片放置到public文件夹中【public文件夹在打包的时候，会把响应的资源原封不动的打包到dist文件夹中】
4. 开始mock（开始虚拟的数据），用mockjs创建，创建mockServer.js，通过mockjs插件实现模拟数据
5. 把 mockServe.js 在入口文件中引入 （至少需要执行一次，才能模拟数据）

**第一步，创建mockServe.js**

```js
// 先引入 mockjs 模块
import Mock from 'mockjs';
// 把 JSON 数据格式引入进来,[json数据没有对外暴露，但是可以引入]
// webapck默认对外暴露的：图片、JSON数据格式
import banner from './banners.json'
import floor from './floors.json'

// mock数据：第一个参数请求地址   第二个参数：请求数据
Mock.mock("/mock/banner", {code: 200, data: banner}); // 模拟首页轮播图数据
Mock.mock("/mock/floor", {code: 200, data: floor});

```

**第二步，创建mockAjax.js**

```js
// 对 axios 进行 二次封装
import axios from 'axios';
// 引入 nprogress --- 进度条
import nProgress from 'nprogress';
// start：进度条开始   done：进度条结束
// 引入进度条的样式, 修改 nprogress中的 .bar 背景颜色 可以修改 进度条的颜色
import 'nprogress/nprogress.css'

// 1.利用axios对象的方法 create，去创建一个 axios 实例
const requests = axios.create({
  // 配置对象
  // 基础路径，发送请求的时候，路径当中会出现 api
  baseURL: '/mock',
  // 请求超时时间
  timeout: 5000,
});

// 请求拦截器 --- 在发送请求之前做一些事情
requests.interceptors.request.use((config) => {
  // config: 配置对象，对象里面有一个属性很重要，headers请求头
  nProgress.start();
  return config;
});

// 响应拦截器 ---  在响应之后做一些事情
requests.interceptors.response.use((res) => {
  // 成功的回调函数：服务器响应数据回来以后，响应拦截器可以检测到，做一些事情
  nProgress.done();
  return res.data;
}, (error) => {
  // 响应失败的回调函数
  return Promise.reject(new Error('faile'));
});

// 向外暴露
export default requests;
```

**第三步，api下的index.js中引入**

```js
// 这个模块： API 进行统一管理
import requests from "./request";
import mockRequests from './mockAjax';

// 三级联动接口
// /api/product/getBaseCategoryList   get   无参
// 发请求   axios 发送请求的返回结果是 一个promise对象

export const reqCategoryList = () => requests.get('/product/getBaseCategoryList');

// 切记：当前函数执行需要把服务器返回结果返回
//  获取banner（home首页轮播图的接口）
export const reqGetBannerList = () => mockRequests.get(`/banner`);

```

**第四步：使用**

```js
// 获取首页轮播图的数据
  async getBannerList({commit}){
    let res = await reqGetBannerList();
    if(res.code == 200){
      commit('GETBANNERLIST', res.data);
    }
  }
```



## 6、ListContainer组件开发重点

安装 Swiper插件，安装@5
swiper插件: 经常制作轮播图（移动端|PC端也可以使用)使用步骤:

第一步:引入相应依赖包（swiper.js|swiper.css）

第二步:页面中的结构务必要有

第三步:初始化swiper实例，给轮播图添加动态效果5 )mock数据,通过mockjs模块实现的

### 遇到的问题：

**在 new Swiper 之前，页面中的结构必须得有 【但是现在在 mounted 中不行】**

```js
/*
	在 new Swiper 之前，页面中的结构必须得有 【但是现在在 mounted 中不行】
    因为 dispatch 当中涉及到了异步语句，导致v-for 遍历的时候结构还没有完全 因此不行
    可以通过 定时器， 在 200ms 之后创建 Swiper
*/
    setTimeout(() => {
      var mySwiper = new Swiper(document.querySelector(".swiper-container"), {
        loop: true,
        // 如果需要分页器
        pagination:{
          el: ".swiper-pagination",
          // 点击小球的时候可以切换
          clickable: true
        },
        // 如果需要前进后退按钮
        navigation:{
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },
      });
    }, 3000);
```

## 7、最完美的解决方法（nextTick）

watch + nextTick：数据监听：已有数据的变化

$nextTick：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。

$nextTick：可以保证页面中的结构一定是有的，经常和很多插件一起使用【都需要DOM存在】

```js
watch: {
    // 监听 bannerList 数据的变化，由 []  ->   [4条数据]
    bannerList:{
      // 现在通过 watch 监听 bannerList 属性的属性值的变化
      // 如果执行 handler 方法，代表组件实例身上这个属性的属性已经有了 【数组：四个元素】
      // 当前这个函数执行：只能保证 bannerList 数据已经有了，但是没办法保证 v-for 已经执行结束了
      // v-for 执行完毕，才有结构【你现在在 watch 当中是没办法保证的】
      // nextTick：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。
      // 在 下次  DOM更新  循环结束之后 执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。
      // 在 bannerList[空]，变成bannerList[4个数据]，并且 v-for 循环结束之后。
      handler(newValue, oldValue){
        this.$nextTick(() => {
          var mySwiper = new Swiper(document.querySelector(".swiper-container"), {
            loop: true,
            // 如果需要分页器
            pagination:{
              el: ".swiper-pagination",
              // 点击小球的时候可以切换
              clickable: true
            },
            // 如果需要前进后退按钮
            navigation:{
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      }
    }
  }
```

# day-05

## 1、组件通信的方式有哪些？

props：用于父子组件通信

1. 自定义事件： @on   @emit  实现子给父通信
2. 全局时间总线： $bus.$emit  $on 全能
3. pubsub-js：vue 当中几乎不用
4. 插槽：默认插槽、具名插槽、作用域插槽、解构插槽
5. vuex

# day-06

## 1、课程中重点内容

**1.1** 排序   order : " " ： 初始状态应该是综合|降序

1：综合  2：价格  asc：升序   desc：降序*

1：asc    1：desc   2：asc   2：desc

**1.2** 考虑问题：哪个标签有 active 属性

谁应该有类名：通过 order 属性值中是包含 1（综合） |  2（价格）

**1.3** 考虑问题：谁应该有箭头？

## 2、分页功能开发

### **1、分页器需要知道的东西：**

- 一共多少页？total
- 每一页多少条数据？pageSize
- 当前第几页？pageNo
- 分页器连续页码的个数：5 | 7 【奇数】，因为奇数对称【好看】

总结：对于分页器需要知道四个前提条件。

### 2、自定义分页器

在测试自定义分页器的时候可以使用自己定义的假数据来测试

### 3、重点！

**对于分页器而言，最重要的是算出，分页器中连续页码的起始数字和结束数字**

```js
// 计算出连续的页码的起始数字与结束数字 [连续的页码数字： 至少是5]
startNumAndEndNum(){
    const {pageNo, continues, totalPage} = this;
    // 先定义两个变量存储起始数字与结束数字
    let start = 0, end = 0;
    // 连续页码数字5，至少是5页，如果出现不正常的现象【就是不够 5 页】
    if(continues > totalPage){
        start = 1; 
        end = totalPage;
    }else{
        // 正常现象【连续页码5，但是你的总页数一定是大于5的】
        start = pageNo - parseInt(continues / 2);
        end = pageNo + parseInt(countinue / 2);
        if(start < 1){
            start = 1;
            continues = 5;
        }
        if(end > totalPage){
            end = totalPage;
            start = totalPage - continues + 1;
        }
    }
    return {start, end}
}
```

## 3、开发详情页面

1：静态组件（详情页的组件：还没有注册为路由组件）

当点击商品的图片的时候，跳转到详情页面，在路由跳转的时候需要带上产品的ID给详情页面

# day-07

## 1、复习JS中的DOM元素的一些样式属性





# day-08

## 1、浏览器的存储功能

- HTML5新增
- 本地存储和会话存储

本地存储：持久化的 ------- 5M

会话存储：并非持久 -------- 会话结束数据消失

## 2、购物车

购物车静态组件 - 需要修改样式结构
调整css让各个项目对齐删除第三项 15 35 10 17 10 13

向服务器发起ajax,获取购物车数据,操作vuex三连环、组件获取数据展示数据发现:发请求的时候，获取不到你购物车里面数据，因为服务器不知道你是谁?

UUID临时游客身份

动态展示购物车数据格式有点不完美

修改购物车产品的数量（需要发请求:参数理解）

修改产品个数【函数节流】，每400ms只能点一次

删除某一个产品

修改产品的状态



# day-09

## 1、登录注册（git）



phone：13700000000

password：111111

# day-10

## 1、登录后首页用户信息展示

## 2、退出登录

## 3、导航守卫

用户已经登录，用户不应该还能跳到 login 登录页

导航：表示路由正在发生改变。进行路由跳转

守卫：看门的守卫，用来给你权限，让你跳或者不跳

**全局守卫**：在项目中，只要发生路由变化，守卫就能监听到。

**路由独享守卫**：相应的路由守卫

**组件内守卫**：只负责组件

## 4、全局守卫

```js
// 全局守卫 ---  前置守卫：（在路由跳转之前进行判断）
router.beforeEach(async (to, from, next) => {
  // to：去哪儿    from：从哪儿    next：放行
  // next()：全部放行，  next('path'):放行到指定的路由，  next(false)
  next();
  let token = store.state.user.token;
  let name = store.state.user.userInfo.name;
  // 用户登陆了
  if(token){
    // 用户登录了，休想去 login ，不能去，停留在首页
    if(to.path == '/login'){
      next('/home');
    }else{
      // 登录了，但是去的不是 login，去的别的地方
      // 如果用户名已经有了
      if(name){
        next();
      }else{
        // 没有用户信息，派发action，让仓库存储用户信息进行跳转
        try {
          // 获取成功
          await store.dispatch("getUserInfo");
          next();
        } catch (error) {
          // token 失效咯，重新登录
          // 清除 token
          await store.dispatch("userLogout");
          next('/login');
        }
      }
    }
  }else{
    // 未登录：不能去交易相关的界面【pay，paysuccess】，不能去个人中心【center】
    // 未登录去上面这些页面，应该去登录-------login
    // 去的不是这些页面，应该放行，home、search、shopcart
    let toPath = to.path;
    if(toPath.indexOf('/trade') != -1 || toPath.indexOf('/pay') != -1 || toPath.indexOf('/center') != -1){
      next('/login?redirect='+toPath);
    }else{
      next();
    }
  }
});
```

## 5、路由独享守卫

```js
{
    path: '/pay',
    component: Pay,
    meta: {show: true},
    // 路由独享守卫
    beforeEnter: (to, from, next) => {
      // 只能从 提交订单  trade 页面来到 进行支付 界面
      if(from.path=='/trade'){
        next();
      }else{
        next(false);
      }
    }
  },
  {
    path: '/trade',
    component: Trade,
    meta: {show: true},
    // 路由独享守卫
    beforeEnter: (to, from, next) => {
      // 想去交易界面，必须从 shopcart 购物车 过来
      if(from.path=='/shopcart'){
        next();
      }else{
        next(false); // 中断当前的导航。如果浏览器的URL改变了(可能是用户手动或者浏览器后退按钮)，那么URL地址会重置到from路由对应的地址。
      }
    }
  }
}
```

## 6、组件内守卫

```js
<script>
  export default {
    name: 'PaySuccess',
    beforeRouteEnter (to, from, next) {
      // 在渲染该组件的对应路由被confirm前调用
      // 不!能!获取组件实例this
      // 因为当守卫执行前,组件实例还没被创建
      if(from.path == '/pay'){
        next();
      }else{
        next(false);
      }
    },
    beforeRouteUpdate(to, from, next){
      // 在当前路由改变,但是该组件被复用时调用
      // 举例来说，对于一个带有动态参数的路径/foo/:id,在/foo/1和/foo/2之间跳转的时候,
      // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
      // 可以访问组件实例 this
      // 当路由中的占位数据发生改变的时候，才会触发
    },
    beforeRouteLeave (to, from, next) {
      // 导航离开组件的时候被调用
      // 可以访问组件实例的 this
    }
  }
</script>
```

# day-11

## 1、是否封装过组件？

分页器  =========  全局组件  pagination

## 2、自定义组件

main.js  引入组件

```js
// 自定义插件
import myPlugins from '@/plugins/myPlugins';
Vue.use(myPlugins, {
  name: 'upper'
});
```

myPlugins.js   自己封装的组件

```js
// vue的插件一定是暴露了一个对象
let myPlugins = {};

myPlugins.install = function(Vue, options){
  // Vue.prototype.$bus：任何组件都可以使用
  // Vue.redirective
  // Vue.component
  // Vue.filter
  Vue.directive(options.name, (element, params) => {
    element.innerHTML = params.value.toUpperCase();
    console.log(params);
  })
}

export default myPlugins
```

在 template中使用

```html
<h1 v-upper="msg"></h1>
```



## 3、验证表单---  VeeValidate

main.js

```js
// 表单校验插件
import '@/plugins/validate';
```

index.vue    在 templat 中使用校验

```html
<div class="content">
    <label>手机号:</label>
    <input placeholder="请输入你的手机号" v-model="phone" name="phone" v-validate="{required: true, regex: /^1\d{10}$/}" :class="{invalid: errors.has('phone')}" />
    <span class="error-msg">{{errors.first("phone")}}</span>
</div>


<div class="content">
    <label>验证码:</label>
    <input placeholder="请输入验证码" v-model="code" name="code" v-validate="{required: true, regex: /^\d{6}$/}" :class="{invalid: errors.has('code')}" />
    <button @click="getCode" style="width: 100px;height: 38px;">获取验证码</button>
    <span class="error-msg">{{errors.first("code")}}</span>
</div>


<div class="content">
    <label>登录密码:</label>
    <input placeholder="请输入密码" v-model="password" name="password" v-validate="{required: true, regex: /^[0-9A-Za-z]{8,20}$/}" :class="{invalid: errors.has('password')}" />
    <span class="error-msg">{{errors.first("password")}}</span>
</div>


<div class="content">
    <label>确认密码:</label>
    <input placeholder="请输入确认密码" v-model="password1" name="password1" v-validate="{required: true, is: password}" :class="{invalid: errors.has('password1')}" />
    <span class="error-msg">{{errors.first("password1")}}</span>
</div>


<div class="controls">
    <input type="checkbox" v-model="agree" name="agree" v-validate="{required: true, 'tongyi': true}" :class="{invalid: errors.has('agree')}" />
    <span>同意协议并注册《尚品汇用户协议》</span>
    <span class="error-msg">{{errors.first("agree")}}</span>
</div>

```

```js
// 这行代码用于判断所有的信息都通过
const success = await this.$validator.validateAll();
```



## 4、图片懒加载

main.js

```js
// 引入插件
import VueLazyLoad from 'vue-lazyload';
import atm from '@/assets/1.jpg';
// 注册插件
Vue.use(VueLazyLoad, {
  // 懒加载默认的图片
  loading: atm
});
```

修改 路由中图片显示的 标签

Search  --   index.vue

```html
<!-- 在路由跳转的时候别忘记带 id params -->
<router-link :to="`/detail/${item.id}`">
    <img v-lazy="item.defaultImg"/>
</router-link>
```

## 5、路由懒加载

  	当打包构建应用时，JavaScript包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。

## 6、打包取消 map 文件

vue.config.js

```js
module.exports = {
  // 打包忽略 map.js 文件
  productionSourceMap: false,
  // 关闭 eslint
  lintOnSave: false,
  // 代理跨域
  devServer: {
    proxy: {
      '/api': {
        target: 'http://gmall-h5-api.atguigu.cn',
        // pathRewrite: {'^/api': ''}
      }
    }
  }
}
```

# 组件通信的方式

## 一：props

**场景：**父子通信

注意事项：

如果父组件给子组件传递数据（函数）：本质是子组件给父组件传递数据

如果父组件给子组件传递的数据（非函数）：本质就是父组件给子组件传递数据

书写方式： 3种

```js
props: ['propOne', 'propTwo']

props: {
    'propOne': Object,
    'propTwo': [String, Number] // 必须是字符串或数字类型
}

props: {
	propOne: {
        type: Number,
        required: true,
        default: 0
    },
   	// 如果是数组或对象，默认值必须是一个函数来返回
    prosTwo: {
        type: Object,
        default() {
        	return {}
        }
    },
    propThree: {
        type: Array,
        default: () => []
    },
    // 自定义一个验证函数
    propFour: {
        validator: (value) => {
            return value > 1
        }
    }
}

```

小提示：路由的props

书写形式： 布尔值，对象、函数形式

```js
{
    path:"/about/:id",
    name:"about",
    component:About,
    props:true
},

{path:"/about/:id",name:"about",component:About,
    props:{
        intro:"百度",
        site:"http://www.baidu.com"
    }
},

{path:"/about/:id",name:"about",component:About,
    props:(route)=>(  {params:route.params, a:1, b:2}  )}

```

## 二：自定义事件

**场景**：子组件给父组件传递数据

$on    $emit

## 三：全局事件总线

**场景**：全能

组件初始化的时候在main.js中：  Vue.$prototype.$bus = this;

$bus.$emit   $bus.$on

## 四：pubsub-js

在React框架中使用比较多

**场景**：万能

## 五：Vuex

**场景**：万能

## 六：插槽

**场景**：父子组件通信----（一般结构）

默认插槽

具名插槽

作用域插槽

# Event

事件注意事项

事件：系统事件，click、双击、鼠标系列等等、自定义事件

事件源、事件类型、事件回调



**原生DOM**：button可以绑定系统事件-----click单机事件等等

**组件标签**：event1 可以绑定系统事件（不起作用，因为属于自定义事件）-------  .native可以把自定义事件改变为原生的DOM事件

**.native，其实是给子组件的根节点绑定了点击事件 ---  事件委派**

```html
<Event1 @click.native="handler1"></Event1>
```



**给原生DOM绑定自定义事件**，这种写法是没有意义的，因为没有办法触发$emit函数

```html
<button @xxx="handler3"> 原生的btn</button>
```



**@click也可以是自定义事件**

```html
test.vue    这里的 click 是 原生的DOM事件
<Event2 @click="handler2" @xxx="handler2"></Event2>

handler2(params){
	console.log(params);   //  66666    777777
}

Event2	 这里的click是自定义事件
<button @click="$emit('click',66666)">分发自定义click事件</button><br>
<button @click="$emit('xxx',77777)">分发自定义xxx事件</button><br>


```



# v-model深入【组件通信的一种方式】

**v-model** 它是vue框架中指令，它主要结合表单元素一起使用（文本框、复选、单选等等)它主要的作用是收集表单数据

v-model实现原理: value与input事件实现的，而且还需要注意可以通过v-model实现父子组件数据同步。

**父组件**：

```vue
<template>
  <div>
    <h2>深入v-model</h2>
    <input type="text" v-model="msg">
    <span>{{msg}}</span>
    <br>
    <h2>深入v-model原理</h2>
    <!-- 原生DOM中，有 oninput 事件，它经常结合表单元素一起使用，当表单元素文本内容发生变化的时候就会触发一次回调 -->
    <input type="text" :value="msg" @input="msg=$event.target.value">
    <span>{{msg}}</span>
    <hr>
    <CustomInput :value="msg" @input="msg = $event" />
    <!-- 上面是实现原理，下面是简写 -->
    <CustomInput v-model="msg" />
  </div>
</template>

<script>
  import CustomInput from './CustomInput.vue'
  export default {
    name: 'ModelTest',
    data() {
      return {
         msg:"我爱塞北的大雪呀"
      }
    },
    components:{
      CustomInput
    }
  }
</script>
```

**子组件**：

```vue
<template>
  <div style="background: #ccc; height: 50px;">
   <h2>input包装组件</h2>
   <input :value="value" type="text" @input="$emit('input', $event.target.value)">
  </div>
</template>

<script >
  export default {
    name: 'CustomInput',
    props: ['value'],
  }
</script>
```

# 属性修饰符sync

【组件通信式一种】可以实现父子组件数据同步。

:money.sync,代表父组件给字符串传递props 【money】给当前子组件绑定一个自定义事件（update:money)

**父组件**

```vue
<template>
  <div>
    小明的爸爸现在有{{ money }}元

    <h2>不使用sync修改符</h2>
    <Child :money="money" @update:money="money = $event"></Child>

    <h2>使用sync修改符</h2>
    <Child2 :money.sync="money"></Child2>
      
  </div>
</template>

<script>
import Child from './Child.vue'
import Child2 from './Child2.vue'
export default {
  name: 'SyncTest',
  data() {
    return {
      money: 10000
    }
  },
  components: {
    Child,
    Child2
  }
}
</script>
```

   **Child**

```vue
<template>
  <div style="background: #ccc; height: 50px;">
    <span>小明每次花100元</span>
    <button @click="$emit('update:money', money-100)">花钱</button>
    爸爸还剩 {{money}} 元
  </div>
</template>

<script>
  export default {
    name: 'Child',
    props: ['money']
  }
</script>

```

**Child2**

```vue
<template>
  <div style="background: #ccc; height: 50px;">
    <span>小明每次花100元</span>
    <button @click="$emit('update:money', money-100)">花钱</button>
    爸爸还剩 {{money}} 元
  </div>
</template>

<script>
  export default {
    name: 'Child2',
    props: ['money']
  }
</script>

```

# $listeners与$attrs

组件通信方式一种

他们两者是组件实例的属性,可以获取到父组件给子组件传递props与自定义事件。

**父组件**

```vue
<template>
  <div>
    <h2>自定义带Hover提示的按钮</h2>
    <el-button icon="el-icon-plus" size="mini">添加</el-button>
    <!-- 把el-button需要的数据传递过去，这里的 click 是自定义事件 -->
     <HintButton type="success" icon="el-icon-plus" title="我是中国人" @click="handler"/>
  </div>
</template>

<script >
import HintButton from './HintButton';
export default {
  name: 'AttrsListenersTest',
  components:{
     HintButton 
  },
  methods: {
    handler() {
       alert('弹弹弹');
    },
  },
}
</script>
```

**子组件**：封装的 el-button

```vue
<template>
  <div>
    <!-- title在a上可以在 hover 的时候，进行自动提示消息 -->
     <a :title="title">
       <!-- 下面这种写法，不能用语法糖 ： ，这种写法可以把父组件传递过来的 props 绑定在 元素身上-->
        <el-button v-bind="$attrs" v-on="$listeners">添加</el-button>
     </a>
  </div>
</template>

<script>
export default {
  name: "",
  props:['title'],
  mounted(){
   /*  
      $attrs 属于组件的一个属性
      this.$attrs:可以获取到父亲传递的数据【props】
      this.$attrs是可以获取父亲传递的props数据，
      如果子组件通过props接受的属性，在attrs属性中是获取不到的
  */
    console.log(this.$attrs);
    // $listeners，它是组件实例身上的一个属性，它可以获取到父组件给子组件传递的自定义事件
    console.log(this.$listeners);
  }
};
</script>
```

# $children与$parent

ref可以获取到某一个组件，子组件

$children组件实例的属性，可以获取到当前组件的全部子组件【数组】

$parent组件实例的属性，可以获取到当前子组件的父组件，进而可以操作父组件的数据与方法

**父组件[爸爸]**

```vue
<template>
  <div>
    <h2>BABA有存款: {{ money }}</h2>
    <button @click="JieQianFromXM(100)">找小明借钱100</button><br />
    <button @click="JieQianFromXH(150)">找小红借钱150</button><br />
    <button @click="JieQianAll(200)">找所有孩子借钱200</button><br />
    <button @click="SendInfo">我是baba</button>
    <br />
    <!-- 小明 -->
    <Son ref="xm" />
    <br />
    <!-- 小红 -->
    <Daughter ref="xh"/>
  </div>
</template>

<script>
import Son from "./Son";
import Daughter from "./Daughter";

export default {
  name: "ChildrenParentTest",
  data() {
    return {
      money: 1000,
    };
  },
  methods: {
    //找儿子借钱
    JieQianFromXM(money) {
      //父组件的数据累加100
      this.money += money;
      this.$refs.xm.money -= money;
    },
    JieQianFromXH(money) {
      //父组件的数据累加150
      this.money += money;
      this.$refs.xh.money -= money;
    },
    JieQianAll(money){
      this.money += 2*money;
      this.$children.forEach(item=>item.money-=money);

      //不建议用枚举获取子组件：因为没办法确定到底是那个子组件
      // this.$children[0].money -=money;

    },
    SendInfo(){
      //在父组件中获取到子组件（数据+方法）
      this.$refs.xm.tinghua();
    }
  },

  components: {
    Son,
    Daughter,
  },
};
</script>
```

**儿子组件**

```vue
<template>
  <div style="background: #ccc; height: 50px;">
    <h3>儿子小明: 有存款: {{money}}</h3>
    <button @click="getQian(50)">给BABA钱: 50</button>
  </div>
</template>

<script>
export default {
  name: 'Son',
  data () {
    return {
      money: 30000
    }
  },
  methods: {
    tinghua(){
        console.log('我是小明，我听爸爸的话');
    },
    getQian(money){
       this.money-=money;
       this.$parent.money+=money;
    }
  }
}
</script>
```

**女儿组件**

```vue
<template>
  <div style="background: #ccc; height: 50px;">
    <h3>女儿小红: 有存款: {{money}}</h3>
    <button @click="getQian(100)">给BABA钱: 100</button>
  </div>
</template>

<script>
export default {
  name: 'Daughter',
  data () {
    return {
      money: 20000
    }
  },
    methods: {
        getQian(money){
            this.money -= money;
            this.$parent.money+=money;
        }
   }
}
</script>

```

# 混入mixin

如果项目当中出现很多结构类似功能，想到组件复用。

如果项目当中很多的组件Js业务逻辑相似，想到mixin。【可以把多个组件Js部分重复、相似地方】

**上面的案例中，两个组件中都有方法： getQian **

使用mixins

**myMixin.js**

```js
export default {
  // 对外暴露的对象，可以放置组件重复的业务逻辑
  methods: {
    getQian(money){
      this.money -= money;
      this.$parent.money+=money;
    },
  }
}
```

**Son组件 和 Daughter组件用法相同**

```vue
<script>
import myMixin from './myMixin/myMixin';
export default {
  name: 'Son',
  mixins: [myMixin],
  data () {
    return {
      money: 30000
    }
  },
  methods: {
    tinghua(){
        console.log('我是小明，我听爸爸的话');
    },
  }
}
</script>

```

# 插槽

可以实现父子组件通信（通信的结构）

默认插槽

具名插槽

作用域插槽：子组件的数据是来自父组件的，但是子组件决定不了他的外观和结构。

**父组件**

```vue
<template>
  <div>
    <h2>效果一: 显示TODO列表时, 已完成的TODO为绿色</h2>
    <!-- 子组件：数据来源于 父组件 -->
    <List :todos="todos">
      <!-- 子组件决定不了结构与外观 -->
      <template slot-scope="todo">
        <span :style="{color : todo.todo.isComplete ? 'red':'green'}">{{todo.todo.text}}</span>
      </template>
    </List>

    <h2>效果二: 显示TODO列表时, 带序号, TODO的颜色为蓝绿搭配</h2>
    <List1 :data="todos">
      <template slot-scope="{row, index}">
        <span :style="{color: row.isComplete? 'red': 'green'}">{{index}} ----- {{row.text}}</span>
      </template>
    </List1>
  </div>
</template>

<script>
  //子组件
  import List from './List'
  import List1 from './List1'
  export default {
    name: 'ScopeSlotTest',
    data () {
      return {
        todos: [
          {id: 1, text: 'AAA', isComplete: false},
          {id: 2, text: 'BBB', isComplete: true},
          {id: 3, text: 'CCC', isComplete: false},
          {id: 4, text: 'DDD', isComplete: false},
        ]
      }
    },
    components: {
      List,
      List1 
    }
  }
</script>
```

**子组件1**

```vue
<template>
  <ul>
    <li v-for="(todo,index) in todos" :key="index">
      <!-- 回传的 slot -->
       <slot :todo="todo"></slot>
    </li>
  </ul>
</template>

<script>
export default {
  name: 'List',
  props: {
    todos: Array
  }
}
</script>
```

**子组件2**

```vue
<template>
  <ul>
    <li v-for="(todo,index) in data" :key="index">
       <slot :row="todo" :index="index"></slot>
    </li>
  </ul>
</template>

<script>
export default {
  name: 'List1',
  props: {
    data: Array
  }
}
</script>
```



## 1、具名插槽

在 2.6.0+ 中已弃用

先前，我们使用具名插槽来自定义模板内容，例如，一个假设的 组件的模板如下：

```html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

在向具名插槽提供内容的时候，我们可以在一个父组件的 元素上使用 slot 特性：

```html
<base-layout>
  <template slot="header">
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template slot="footer">
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

或者直接用在一个普通的元素上：

```html
<base-layout>
  <h1 slot="header">Here might be a page title</h1>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <p slot="footer">Here's some contact info</p>
</base-layout>
```

上述两个示例渲染出来的 HTML 都将会是：

```html
<div class="container">
  <header>
    <h1>Here might be a page title</h1>
  </header>
  <main>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </main>
  <footer>
    <p>Here's some contact info</p>
  </footer>
</div>
```

我们可以使用 v-slot 指令改写上面的栗子：

```html
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

**就是这么简单，插槽的名字现在通过 v-slot:slotName 这种形式来使用。**

Tips: *没有名字的 隐含有一个 “default” 名称*

例如，上面的默认插槽，如果你想显示调用的话，可以这样：

```html
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <template v-slot:default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

无论哪种方式，上面的代码都将输出为下面代码：

```html
<div class="container">
  <header>
    <h1>Here might be a page title</h1>
  </header>
  <main>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </main>
  <footer>
    <p>Here's some contact info</p>
  </footer>
</div>
```

请注意， v-slot 只能添加到`template` 或**自定义组件**上，这点与弃用的 slot 属性不同



## 2、作用域插槽

有时候，我们想在父组件中访问子组件内部的一些可用数据。例如，假设有一个下面模板的 `<current-user>` 组件：

```html
<span>
  <slot>{{ user.lastName }}</slot>
</span>
```

我们可能想用用户的名字来替换掉插槽里面的姓，于是我们这样写：

```html
<current-user>
  {{ user.firstName }}
</current-user>
```

很不幸，上面这段代码不能如你预期那样工作，因为当前代码的作用域环境是在父组件中，所以它访问不了 `<current-user>` 内部的数据。

为了解决这个， 我们可以在 `<current-user>` 内部的 `<slot>` 元素上动态绑定一个 user 对象属性：

```html
<span>
  <!-- 完整 v-bind:user 下面是简写形式 -->
  <slot :user="user">
    {{ user.lastName }}
  </slot>
</span>
```

绑定到 `<slot>` 元素上的属性我们称之为 slot props。现在，在父作用域中，我们可以通过 slot-scope 来访问 user 数据了：

```html
<current-user>
  <template slot-scope="slotProp">
    {{ slotProp.user.firstName }}
  </template>
</current-user>
```

同样的，我们使用 v-slot 重构上面的代码：

```html
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>
</current-user>
```

或者直接作用在 `<current-user>` 上的写法：

```html
<!-- 省略默认插槽名字 -->
<current-user v-slot="slotProp">
  {{ slotProp.user.firstName }}
</current-user>

<!-- 显示调用默认插槽名字 -->
<current-user v-slot:default="slotProp">
  {{ slotProp.user.firstName }}
</current-user>
```

在这个栗子中，我们选择 slotProp 作为我们的 slot props 名字，但你可以使用你喜欢的任何名字。

单个默认插槽的缩写形式
在上述情况下，当且仅当提供了默认插槽内容时，我们可以使用 v-slot 直接作用在组件上：

```html
<current-user v-slot:default="slotProps">
  {{ slotProps.user.firstName }}
</current-user>
```

我们可以简化上面的的默认插槽写法：

```html
<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
</current-user>
```

请注意了，默认插槽的缩写语法不能与具名插槽混用：

```html
<!-- 控制台将报警告：-->
<!-- To avoid scope ambiguity, the default slot should also use <template> syntax when there are other named slots. -->
<!-- 意思就是说，为了避免作用域模糊 -->
<!-- 当有其他具名插槽时，默认插槽也应当使用 '<template>' 模板语法 -->
<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
  <template v-slot:other="otherSlotProps">
    slotProps is NOT available here
  </template>
</current-user>
```

于是，上面的代码，我们改写成：

```html
<current-user>
 <!-- 两种写法均可 -->
  <!--<template v-slot="slotProps">
    {{ slotProps.user.firstName }}
  </template>-->
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>

  <template v-slot:other="otherSlotProps">
    ...
  </template>
</current-user>
```

插槽内容的解构赋值
在 Vue 代码内部，我们传递的 slotProps 其实就是函数的一个单一参数：

```js
function (slotProps) {
  // ... slot content ...
}
```

这也就意味着 v-slot 的值只要满足函数参数定义的 JavaScript 表达式的都可以接受。因此，在支持的环境（单文件或现代浏览器）中，你还可以使用 ES2015 解构语法来提取特定的插值内容，例如：

```html
<current-user v-slot="{ user }">
  {{ user.firstName }}
</current-user>
```

代码看起来更简洁对吧。我们还可以重命名解构变量：

```html
<current-user v-slot="{ user: person }">>
  {{ person.firstName }}
</current-user>
```

这给了我们很多自由操作的空间，你甚至可以自定义回退内容，以便在未定义插值情况下使用：

```html
<current-user v-slot="{ user = { firstName: 'Guest' } }">>
  {{ user.firstName }}
</current-user>
```

## 3、动态插槽名称

2.6.0+ 新增

动态指令参数 也适用于 v-slot ，允许我们定义动态插槽名称：

```html
<base-layout>
  <template v-slot:[dynamicSlotName]>
    ...
  </template>
</base-layout>
```

## 4、命名插槽简写

2.6.0+ 新增

与 v-on 和 v-bind 类似，v-slot 也有一个简写，**即使用 # 代替 v-slot**。例如， v-slot:header 简写成 #header:

```html
<base-layout>
  <template #header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template #footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```

和其他指令一样，只有在提供参数时才能使用简写形式，下面的写法是无效的：

```html
<!-- 将会触发一个控制台警告 -->
<current-user #="{ user }">
  {{ user.firstName }}
</current-user>
```

也就是说，如果你想使用简写语法，则务必指定插值的名字：

```html
<current-user #default="{ user }">
  {{ user.firstName }}
</current-user>
```

总结：
1、原来的vue插槽有三种 ：匿名插槽 具名插槽和作用域插槽（solt-scope）
2、vue2.6+之后采用v-slot指令来代替原来的三种插槽
3、v-slot代替作用域插槽的时候子组件仍然需要绑定向父组件暴露的属性
4、v-slot属性可以简写成# 但是后面必须带有插槽名称才能简写
5、v-slot可以直接访问组件绑定的属性 不需要通过取名字 v-slot="{ user }"
6、v-slot最好都写在`<templete>`中







