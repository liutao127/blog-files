---
title: HTTP重点汇总
date: 2022-04-03 11:10:08
tags: HTTP
---

# 1、HTTP报文结构

<!-- more -->

HTTP报文由**报文首部**和**报文主体**构成，中间由一个**空行分隔**。**报文首部包含请求行和请求头部**，报文主体主要包含被发送的信息。

报文首部是客户端或服务端需要处理请求或响应的内容及属性，可以传递额外的信息。

一个HTTP报文示例：

```http
GET /index.html HTTP/1.1
Host: www.enjoytoday.cn
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Referer: http://www.enjoytoday.cn/posts/326
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8

username=hfcai&sex=man
```



## 1-1. 请求报头

一个HTTP请求报文由**请求行，请求头部，空行和请求数据**4部分组成。

{% asset_img  1.png %}

请求行：三部分组成，方法 + URI + HTTP版本

请求头部：首部字段名和字段值构成，中间用 : 分隔。首部字段格式： 首部字段名:字段值



## 1-2. 响应报文

HTTP响应报文由**状态行、响应头部、空行和响应体**4部分组成

{% asset_img  2.png %}

状态行：HTTP版本 + 状态码 + 响应短语



# 2、HTTP首部字段

## 常见请求头

| 字段名            | 说明                                                         | 示例                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept            | 能够接受的回应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Accept-Charset    | 能够接受的字符集                                             | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 能够接受的编码方式列表                                       | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 能够接受的回应内容的自然语言列表                             | Accept-Language: en-US                                       |
| Authorization     | 用于超文本传输协议的认证的认证信息                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 | Cache-Control: no-cache                                      |
| Connection        | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive Connection: Upgrade                   |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie | Cookie: $Version=1; Skin=new;                                |
| Content-Length    | 以 八位字节数组 （8位的字节）表示的请求体的长度              | Content-Length: 348                                          |
| Content-Type      | 请求体的 多媒体类型                                          | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                                       | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| Expect            | 表明客户端要求服务器做出特定的行为                           | Expect: 100-continue                                         |
| Host              | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号 | Host: en.wikipedia.org:80 Host: en.wikipedia.org             |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                 |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改                | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT             |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回304未修改                | If-None-Match: "737060cd8c284d8af7ad3082f209582d"            |
| If-Range          | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 | If-Range: "737060cd8c284d8af7ad3082f209582d"                 |
| Range             | 仅请求某个实体的一部分                                       | Range: bytes=500-999                                         |
| User-Agent        | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            | 发起一个针对 跨来源资源共享 的请求                           | Origin: http://www.example-social-network.com                |



## 2-1.HTTP通用首部字段

通用首部字段是请求报文和响应报文都会使用的字段，例如：

| 通用头部字段      | HTTP1.0 | HTTP1.1 | 含义                                                         |
| ----------------- | ------- | ------- | ------------------------------------------------------------ |
| **Date**          | 有      |         | 表示请求和响应生成的日期，GTM时间。例如 `Tue, 02 Mar 2021 12:31:25 GMT` |
| Pragma            | 有      |         | 表示数据是否允许被缓存的通信选项                             |
| **Cache-Control** |         | 有      | 控制缓存的相关信息                                           |
| **Connection**    |         | 有      | 设置发送响应之后 TCP 连接是否继续保持                        |
| Transfer-Encoding |         | 有      | 表示消息主体的编码格式                                       |
| Via               |         | 有      | 记录途中经过的代理和网关                                     |



## 2-2. HTTP请求首部字段

| 通用头部字段                | HTTP1.0 | HTTP1.1 | 含义                                                         |
| --------------------------- | ------- | ------- | ------------------------------------------------------------ |
| Host                        |         | 有      | 接受请求的服务器IP地址和端口号                               |
| Accept                      | 有      | 有      | 客户端可支持的数据类型                                       |
| **User-Agent**              | 有      | 有      | 客户端软件的名称和版本号等相关信息                           |
| **If-Modified-S\**\*rong>** | 有      | 有      | UMT时间，表示该时间之后资源是否修改                          |
| **If-None-Match**           |         | 有      | 返回服务器响应头的 Etag 值                                   |
| Referer                     | 有      | 有      | 通过点击超链接进入下一个页面时，在这里会记录上一个页面的 URI |
| Accept-Encoding             | 有      | 有      | 客户端可支持的编码格式                                       |
| Accept-Language             | 有      | 有      | 客户端可支持的语言                                           |
| If-Match                    |         | 有      |                                                              |
| If-Unmodified-Since         |         | 有      |                                                              |
| Range                       |         | 有      | 当只需要回去部分数据时，可通过这个字段指定要获取的数据范围   |



## 2-3. HTTP响应首部字段

| 通用头部字段 | HTTP1.0 | HTTP1.1 | 含义                             |
| ------------ | ------- | ------- | -------------------------------- |
| Location     | 有      | 有      | 表示信息的准确位置，绝对路径     |
| Server       | 有      | 有      | 服务器程序的名称和版本号相关信息 |



## 2-4. HTTP实体（消息体）首部字段

| 通用头部字段      | HTTP1.0 | HTTP1.1 | 含义                               |
| ----------------- | ------- | ------- | ---------------------------------- |
| Allow             | 有      | 有      | 表示指定的 URI 支持的方法          |
| Content-Encoding  | 有      | 有      | 消息的编码格式                     |
| Content-Length    | 有      | 有      | 消息体的长度                       |
| Content-Type      | 有      | 有      | 消息体的数据类型                   |
| **Expires**       | 有      | 有      | 消息体的有效期，UMT 时间           |
| **Last-Modified** | 有      | 有      | 数据最后更新的日期                 |
| **Etag**          |         | 有      | 资源的唯一标识符，控制是否使用缓存 |



# 3、HTTP方法



根据 HTTP 标准，HTTP 请求可以使用多种请求方法。

HTTP1.0 定义了三种请求方法：GET、POST 和 HEAD 方法

HTTP1.1 新增了六种方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法

| 方法    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 用于从服务器获取数据                                         |
| HEAD    | 类似于 GET 请求，只不过响应中没有具体的内容，**用户获取报头** |
| POST    | 向指定资源提交数据进行处理请求。数据被包含在请求体中，POST请求可能导致新的资源的建立或已有资源的修改 |
| PUT     | 客户端向服务器传送的数据取代指定的文档内容                   |
| DELETE  | 请求服务器删除指定的资源                                     |
| OPTIONS | 允许客户端查看服务器的性能                                   |
| CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

GET与POST方法的区别：

1. get 是从指定的资源请求数据，post 是向指定的资源提交要处理的数据 
2. get 请求可以被缓存，post 请求不会被缓存 
3. get 请求传输的数据有长度限制，一般为 2048 字符，post 请求传输的数据没有大小限制 
4. get 请求的数据一般追加在 URL 的末尾，post 请求的数据在 http 请求体中 

一般不使用 GET 请求发送如密码这样的敏感信息。我认为 get 请求比 post 请求更安全。



# 4. 常见的HTTP状态码



| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 100    | 继续                                                         |
| 101    | 切换协议                                                     |
| 200    | 请求成功                                                     |
| 204    | 无内容。服务器处理成功，但未返回内容。在未更新网页的情况下可确保浏览器继续显示当前文档 |
| 206    | 服务器成功处理了部分 GET 请求                                |
| 301    | 永久移除。请求的资源已被永久移动到新 URI，返回的信息包括新的 URI，浏览器会自动定向到新 URI。今后任何请求都应该使用新的 URI 代替 |
| 302    | 临时移除。资源被临时移除，客户端应继续使用当前 URI           |
| 303    | 告诉客户端应该用另一个 URL 获取资源                          |
| 304    | 未修改。资源未修改，服务器不会返回任何资源，告诉浏览器使用本地缓存 |
| 400    | 客户端请求的语法错误，服务端无法理解                         |
| 401    | 要求用户进行身份认证                                         |
| 403    | 服务器拒绝请求                                               |
| 404    | 资源未找到                                                   |
| 500    | 服务器内部错误                                               |
| 502    | 服务器作为网关或者代理，从远程服务器接收到了一个无效的响应   |
| 503    | 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。   |
| 504    | 网关超时，服务器作为网关或者代理，但是没有及时从远程服务器收到请求 |

# 5. HTTP-304状态码



```http
https://zhuanlan.zhihu.com/p/111190645
```

304状态码是在协商缓存，缓存命中的时候服务器返回的，告诉客户端，服务器资源没有修改，可以使用客户端自己的缓存。

浏览器缓存分**为强缓存（本地缓存）和协商缓存（弱缓存）**。

{% asset_img  3.png %}

如上图所示，在浏览器第一次发出请求之后，需要再次发送请求的时候，浏览器首先获取该资源缓存的 header 信息，然后根据 Cache-Control 和 Expires 字段判断缓存是否过期。如果没有过期，直接使用浏览器缓存，并不会与服务器通信。该过程为判断是否使用强缓存，即本地缓存。

**1. Cache-Control**

​	该字段是 HTTP1.1 规范，一般利用该字段的 max-age 属性来判断，这个值是一个相对时间，单位为 s，代表资源的有效期。例如：	

```http
Cache-Control:max-age=3600
```

​	除此之外还有几个常用的值：

- no-cache：表示**不使用强缓存**，需要使用协商缓存 
- no-store：禁止**浏览器缓存数据**，每次请求下载完整的资源 
- public：可以被所有用户缓存，包括终端用户和中间代理服务器 
- private：只能被终端用户的浏览器缓存

**2.Expires**

该字段是 HTTP1.0 规范，他是一个绝对时间的 GMT 格式的时间字符串。例如：

```http
expires:Mar, 06 Apr 2020 10:57:09 GMT
```

这个时间代表资源的失效时间，只要发送请求的时间在这之前，都会使用强缓存。

由于失效时间是一个绝对时间，因此当**服务器时间与客户端时间偏差较大时，就会导致缓存混乱**。



如果缓存过期，浏览器会向服务器发送请求，即使用协商缓存。本次请求会带着第一次请求返回的有关缓存的 header 字段信息，比如以下两个字段：

**1. Etag/If-None-Match**

判断响应头中是否存在 Etag 字段，如果存在，浏览器则发送一个带有 If-None-Match 字段的请求头的请求，该字段的值为 Etag 值。服务器通过对比客户端发过来的Etag值是否与服务器相同。如果相同，说明缓存命中，服务器返回 304 状态码，并将 If-None-Match 设为 false，客户端继续使用本地缓存。如果不相同，说明缓存未命中，服务器返回 200 状态码，并将 If-None-Match 设为 true，并且返回请求的数据。

**2. Last-Modified/If-Modified-S\**\*rong>**

除了 Etag 字段之外，客户端还会通过服务器返回的 Last-Modified 字段判断是否继续使用缓存，该字段为服务器返回的资源的最后修改时间，为UMT时间。浏览器发送一个带有 If-Modified-Since 字段的请求头的请求给服务器，该字段的值为 Last-Modified 值。服务器收到之后，通过这个时间判断，在该时间之后，资源有无修改，如果未修改，缓存命中，返回 304 状态码；如果未命中，返回 200 状态码，并返回最新的内容。



**Cache-Control 与 Expires 的优先级：**

 两者可以在服务端配置同时使用，**Cache-Control 的优先级高于 Expires。**

**Last-Modified/If-Modified-Since 已经可以判断缓存是否失效了，为什么出现 Etag/If-None-Match?**

 Etag/If-None-Match 是实体标签，是一个资源的唯一标识符，资源的变化都会导致 ETag 的变化。出现 Etag 的主要原因是解决 Last-Modified 比较难解决的问题：

- 一些文件也许会周期性的修改，但是他的内容并不发生改变，这个时候我们并不希望客户端认为这个文件修改了 
- 某些文件在秒以下的时间内进行修改了，If-Modified-Since无法判断。UNIX时间只能精确到秒 

Last-Modified 和 Etag 可以一起使用， **Etag 的优先级更高**。

**刷新页面的问题：**

F5刷新：不使用强缓存，使用协商缓存

ctrl+F5：二者都不使用

# 6、HTTP与HTTPS以及区别及实现方式

```http
https://www.runoob.com/w3cnote/http-vs-https.html
```

## HTTP

`HTTP` (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范。

`HTTP`是一个传输协议，即将数据由A传到B或将B传输到A，并且 A 与 B 之间能够存放很多第三方，如： A<=>X<=>Y<=>Z<=>B。

`HTTP`常被用于在`Web`浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密

默认端口：80，工作方式如下：

例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：

- 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
- 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
- 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
- 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
- 释放 TCP连接;
- 浏览器将该 html 文本并显示内容; 

特点如下：

- 支持客户/服务器模式
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
- 无状态：HTTP协议无法根据之前的状态进行本次的请求处理

## HTTPS

**HTTPS是超文本传输安全协议**，是一种安全通信的传输协议。

`HTTPS`出现正是为了解决`HTTP`不安全的特性。

HTTPS经**由HTTP进行通信，但利用 SSL/TSL 来进行加密数据包**。HTTPS开发的主要目的是提供网站服务器的身份认证，为浏览器和服务器之间的通信进行加密，保护数据交换的隐私与完整性。

## SSL（Secure Sockets Layer ）/ TLS

[SSL](https://so.csdn.net/so/search?q=SSL&spm=1001.2101.3001.7020)（Secure Sockets Layer），中文：“安全套接层”。上世纪90年代中期，由网景公司设计的。到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport [Layer](https://so.csdn.net/so/search?q=Layer&spm=1001.2101.3001.7020) Security”的缩写），中文叫做“传输层安全协议”。

`SSL` 协议位于`TCP/IP` 协议与各种应用层协议之间，浏览器和服务器在使用 `SSL` 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持

HTTPS默认工作在 TCP 的443 端口，它的工作方式如下：

- TCP三次同步握手 
- 服务端将网站支持的证书信息（证书中包含公钥）传送一份给客户端
- 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
- 服务器利用自己的私钥解密出会话密钥，SSL 安全加密隧道协商完成 
- 网页以加密的方式进行传输，用协商的对称加密[算法]()和密钥加密，保障数据机密性；用协商的 hash [算法]()进行数据完整性保护，保证数据不被篡改。

{% asset_img  SSL连接的建立.png %}

## HTTP 与 HTTPS 的区别

- HTTP 使用明文传输，数据都是未**加密**的，安全性较差；HTTPS 数据传输过程是加密的，安全性较好； 
- HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高。使用 HTTPS 一般需要到 CA 申请**证书** 
- HTTP页面的响应比 HTTPS **快**，主要是因为 HTTPS 除了 TCP 的三个包之外，还要加上 ssl 握手的 9 个包 
- HTTP 和 HTTPS 是完全不同连接方式，用的**端口**也不一样， 前者是80， 后者是 443 
- HTTPS 其实就是建构在 SSL/TSL 之上的 HTTP 协议，所以要比 HTTP 更消耗**服务器资源**---------HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP



## HTTPS 的工作方式

{% asset_img  4.png %}

1. 客户端发起 HTTPS 请求

   建立TCP连接之后，客户端发起请求

2. 服务端的配置

   服务端收到请求之后，会有一套公钥和私钥，这对公钥和私钥其实就是一套数字证书，一般都是由受信任的证书颁发机构进行签发。

3. 传送公钥

   服务端将公钥传递给客户端，里面包含很多信息，如证书的颁发机构，证书的过期时间

4. 客户端解析证书

   这部分工作由客户端的 TSL 来完成，首先验证证书是否有效。如果没有问题，就会随机生成一个 key，然后利用公钥对 key 的值进行加密。

5. 传送加密的信息（key）

   将加密过后的 key 传递给服务器

6. 使用私钥解析加密信息（key）

   服务器使用自己的私钥解密加密信息得到 key

7. 使用客户端的 key，利用对称加密加密信息，并发送给客户端

   把内容通过该 key 进行对称加密，并传输给客户端

8. 客户端使用 key 解密信息

   客户端收到信息之后利用 key 进行解密

重点：客户端会生成 key，key 的传输使用非对称加密，而数据的传输使用 key 进行对称加密。

对称加密：加密密钥和解密密钥是同一个，效率较高

非对称加密：加密密钥和解密密钥不是同一个，效率较低

**由于非对称加密的效率比较低，因此我们通常不使用非对称加密对整个文件进行加密，而采用对称加密对文件加密，非对称加密对对称加密的密钥加密，然后将对称加密后的文件和非对称加密后的密钥一起在网上传送。**



## SSL 的位置

{% asset_img  5.png %}

在发送方，SSL接受应用层的数据（如HTTP或者IMAP报文），对数据进行加密，然后把加了密的数据送往TCP套接字。

在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。

使用非对称加密进行文件传输。通信双方在传输时需要交换各自的公钥。

**SSL提供以下三个功能：**

（1）SSL服务器鉴别：允许用户证实服务器的身份。具有SSL功能的浏览器维持一个表，上面有一些可信赖的认证中心CA（Certificate Authority）和它们的公钥。

（2）加密的SSL会话：客户和服务器交互的所有数据都在发送方加密，在接收方解密。

（3）SSL客户鉴别：允许服务器证实客户的身份。

# 7、HTTP1.0与HTTP1.1以及HTTP2.0 和 http3.0的区别

## HTTP1.0 && HTTP1.1

1. **长连接**

   在HTTP1.0中，TCP每建立一次连接就只能发送一个 HTTP 请求并得到一个响应，当需要再次发送请求的时候，又得重新建立 TCP 连接，这样就会很耗时间，传输效率较低。

   HTTP1.1中支持长连接和流水线传输，在一个 TCP 连接中可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。在 HTTP1.1 中默认开启 Connection: Keep-Alive，一定程度上弥补了 HTTP1.0 的缺点

2. **缓存处理**

   在 HTTP1.0 中主要使用 Expires、Last-Modified、If-Modified-Since 头部字段来作为缓存判断的标准

   在 HTTP1.1 中增加了 Cache-Control、Etag、If-None-Match、If-Match 等头部字段来提供可选的更多的缓存策略

3. **带宽优化及网络连接的使用**

   HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。

   HTTP1.1 中引入了 Range 头部字段，它允许只请求资源的某个部分，即返回状态码是 206

4. **Host头处理**

   在 HTTP1.0 中认为每台服务器绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名。但随着虚拟技术的发展，在一台物理设备上可以存在多台虚拟主机，并且他们共享同一 IP 地址 。在 HTTP1.1 的请求消息和响应消息中都应支持 HOST 头域，且请求消息中没有 HOST 头域会报一个错误。

5. **错误通知的管理**

   HTTP1.1 中新增了 24 个错误状态码，如 409 表示请求的资源与资源的当前状态发生冲突；410表示服务器上的某个资源被永久性删除。

{% asset_img  6.png %}



## http2.0

1. 多路复用，如上

2. 首部压缩

   `HTTP/2`在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送

   首部表在`HTTP/2`的连接存续期内始终存在，由客户端和服务器共同渐进地更新

   例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销

   在 1.1 中消息体一般都会经过gzip压缩或者本身传输的就是压缩过后的二进制文件，而**消息头部是以文本进行传输的**。但是在2.0中对消息头部进行了压缩。

3. 二进制分帧

   帧是`HTTP2`通信中最小单位信息

   `HTTP/2` 采用二进制格式传输数据，而非 `HTTP 1.x`的文本格式，解析起来更高效

   将请求和响应数据分割为更小的帧，并且它们采用二进制编码

   `HTTP2`中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流

   每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件

4. 服务器推送

   服务端推送是一种在客户端请求之前发送数据的机制。

   在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。

    为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

{% asset_img  7.jpg %}

## 总结

HTTP1.0：

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

HTTP1.1：

- 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
- 在同一个TCP连接里面，客户端可以同时发送多个请求
- 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
- 新增了一些请求方法
- 新增了一些请求头和响应头

HTTP2.0：

- 采用二进制格式而非文本格式
- 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
- 使用报头压缩，降低开销
- 服务器推送

## http3.0

HTTP3.0，也称作HTTP over QUIC。HTTP3.0的核心是QUIC(读音quick)协议，由Google在 2015年提出的SPDY v3演化而来的新协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层[UDP](https://so.csdn.net/so/search?q=UDP&spm=1001.2101.3001.7020)上的协议，可以定义成:HTTP3.0基于UDP的安全可靠的HTTP2.0协议。

{% asset_img  http3.0-1.png %}

QUIC 协议针对基于TCP和TLS的HTTP2.0协议解决了下面的问题。

### 1.1 减少了TCP三次握手及TLS握手时间

{% asset_img  http3.0-2.gif %}

### 1.2 多路复用丢包的线头阻塞问题

QUIC保留了HTTP2.0多路复用的特性，在之前的多路复用过程中，同一个TCP连接上有多个stream，假如其中一个stream丢包，在重传前后的stream都会受到影响，而QUIC中一个连接上的多个stream之间没有依赖。所以当发生丢包时，只会影响当前的stream，也就避免了线头阻塞问题。

### 1.3 优化重传策略

以往的TCP丢包重传策略是:在发送端为每一个封包标记一个编号(sequence number)，接收端在收到封包时，就会回传一个带有对应编号的ACK封包给发送端，告知发送端封包已经确实收到。当发送端在超过一定时间之后还没有收到回传的ACK，就会认为封包已经丢失，启动重新传送的机制，复用与原来相同的编号重新发送一次封包，确保在接收端这边没有任何封包漏接。这样的机制就会带来一些问题，假设发送端总共对同一个封包发送了两次(初始＋重传)，使用的都是同一个sequence number:编号N。之后发送端在拿到编号N封包的回传ACK时，将无法判断这个带有编号N的ACK，是接收端在收到初始封包后回传的ACK。这就会加大后续的重传计算的耗时。QUIC为了避免这个问题，发送端在传送封包时，初始与重传的每一个封包都改用一个新的编号，unique packet number，每一个编号都唯一而且严格递增，这样每次在收到ACK时，就可以依据编号明确的判断这个ACK是来自初始封包或者是重传封包。

### 1.4 流量控制

通过流量控制可以限制客户端传输资料量的大小，有了流量控制后，接收端就可以只保留相对应大小的接收 buffer ,优化记忆体被占用的空间。但是如果存在一个流量极慢的stream ，光一个stream就有可能估用掉接收端所有的资源。QUIC为了避免这个潜在的HOL Blocking，采用了连线层(connection flow control)和Stream层的(streamflow control)流量控制，限制单一Stream可以占用的最大buffer size。

### 1.5 连接迁移

TCP连接基于四元组（源IP、源端口、目的IP、目的端口)，切换网络时至少会有一个因素发生变化，导致连接发生变化。当连接发生变化时，如果还使用原来的TCP连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久。如果实现得好，当检测到网络变化时立刻建立新的TCP连接，即使这样，建立新的连接还是需要几百毫秒的时间。QUIC的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持。QUIC连接不以四元组作为标识，而是使用一个64位的随机数，这个随机数被称为Connection lD，对应每个stream，即使IP或者端口发生变化，只要Connection ID没有变化，那么连接依然可以维持。

# 8、HTTP建立持久连接的意义



在 HTTP1.0 中每发送一次请求都要重新建立 TCP 连接并且关闭连接。这样做是很耗费时间的。而在HTTP1.1 中默认开启长连接，一次TCP连接可以发送多个HTTP请求，避免了重复建立释放连接的开销，加速了数据的传输，节省了时间和带宽。

**那么长连接什么时候会释放呢？**

客户端的长连接不可能一直拿着，会有一个超时时间，服务器会告诉客户端超时时间，譬如：

```http
Access-Control-Allow-Origin: http://mall.sillywa.com
Connection: keep-alive
Content-Length: 43574
Content-Type: application/json; charset=utf-8
Date: Wed, 03 Mar 2021 07:34:49 GMT
Keep-Alive: timeout=5
Vary: Origin
```



**Keep-Alive: timeout=5 表示这个 TCP 通道可以保持 5s**。**另外还可能有 max=xxx，表示这个长连接最多接受xxx次请求就断开**。对于客户端来说，如果服务端没有告诉是客户端超时时间也没关系，服务端可能主动发起四次挥手断开TCP连接，客户端就能够知道该TCP连接已经无效。

**长连接数据传送完成识别：**

1. 判断传输的数据是否达到了 Content-Length 指示的大小 
2. 没有 Content-Length，由于数据是分块传输的，这时候就要根据块的编码来判断了，最后一个一个编码的数据是一个空块，表明本次传输结束

# 9、Cookie、Session 和 Token



## 发展史

1、很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了HTTP请求， 每个请求对我来说都是全新的。这段时间很嗨皮。

2、但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放商品， 也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样， 每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了

3、这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！ 如果访问服务器多了， 就得由成千上万，甚至几十万个。

这对服务器说是一个巨大的开销 ， 严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统， 那session id会保存在机器A上， 假设小F的下一次请求被转发到机器B怎么办？ 机器B可没有小F的 session id啊。

有时候会采用一点小伎俩： **session sticky** ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。

那只好做session 的复制了， 把session id 在两个机器之间搬来搬去， 快累死了。

{% asset_img  11.jpg %}

后来有个叫Memcached的支了招： 把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了， 所有人都得重新登录一遍， 估计得被人骂死。

{% asset_img  12.jpg %}

也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的session 对我来说是一个沉重的负担

4、于是有人就一直在思考， 我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？

可是**如果不保存这些session id , 怎么验证客户端发给我的session id 的确是我生成的呢？** 如果不去验证，我们都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。

嗯，对了，关键点就是验证 ！

*比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。*

那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。

{% asset_img  13.jpg %}

这个token 我不保存， 当小F把这个token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。

{% asset_img  14.jpg %}

Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。

当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。

这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， 我用我的CPU计算时间获取了我的session 存储空间 ！

解除了session id这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 这种无状态的感觉实在是太好了！

```
这里的意思就是说：
客户端： 小F登录系统的时候，发送的数据中保存了自己的身份信息（数据）还有你（服务器）之前发给我的的令牌（token），然后发送请求的时候呢，把当前用户数据和token一并发送过来。
服务器： 我收到了你发送的请求之后，我对你的数据(用户信息)进行处理（算法+密钥），【因为密钥只有我知道，别人是不可能知道的，所以就无法伪造】，之后我就得到了这个新的token，然后用这个新的token和你发过来的token作比较，如果相同的话,就直接获取到了用户的基本信息，就登陆成功，如果不相同，那么对不起，登录失败。
```



## Cookie

cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。

cookie由**服务器生成**，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是**存在客户端**上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。



## Session

Session是另一种记录服务器和客户端会话状态的机制，Session是基于Cookie实现的，而Session是**存储在服务器**里，Cookie是存储在客户端中，但是服务器生成 的SessionID是存储到了Cookie中。

- 用户第一次请求服务器的时候，服务器根据用户提交的信息，创建对应的Session，并通过该Session生成SessionID返回给浏览器。
- 浏览器收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。
- 当用户第二次请求服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

## Token

在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。

以下几点特性会让你在程序中使用基于Token的身份验证

1. 无状态、可扩展
2. 支持移动设备
3. 跨程序调用
4. 安全



## 基于Token的验证原理

基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。

这种概念解决了在服务端存储信息时的许多问题

NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。

基于Token的身份验证的过程如下:

1. 用户通过用户名和密码发送请求。
2. 程序验证。
3. 程序返回一个签名的token 给客户端。
4. 客户端储存token,并且每次用于每次发送请求。
5. 服务端验证token并返回数据。

每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。

需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。

实现思路：

{% asset_img  15.jpg %}

1. 用户登录校验，校验成功后就返回Token给客户端。
2. 客户端收到数据后保存在客户端
3. 客户端每次访问API是携带Token到服务器端。
4. 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码

当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。

我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token）



## Tokens的优势

### **无状态、可扩展**

token 自身包含了身份验证所需要的所有信息，使得我们的服务器不需要存储 Session 信息，这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。

在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。

### **安全性**

请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。

token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。

### 防止[CSRF]攻击

**CSRF（Cross Site Request Forgery）** 一般被翻译为 **跨站请求伪造**，属于网络攻击领域范围。构成这个攻击的原因，就在于 Cookie + Session 的鉴权方式中，鉴权数据（cookie 中的 session_id）是由浏览器自动携带发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。而 token 是通过客户端本身逻辑作为动态参数加到请求中的，token 也不会轻易泄露出去，因此 token 在 CSRF 防御方面存在天然优势。

### 适合移动应用

移动端上不支持 cookie，而 token 只要客户端能够进行存储就能够使用，因此 token 在移动端上也具有优势。

### 单点登录友好

使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 token 进行认证的话， token 被保存在客户端，不会存在这些问题。

### **可扩展性**

Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。

使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。

### **多平台跨域**

我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。

> Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application.

只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。

```text
Access-Control-Allow-Origin: *      
```

基于标准创建token的时候，你可以设定一些选项。标准的用法会在JSON Web Tokens体现。

最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。

## Tokens的劣势

### 无状态问题

token 的无状态，导致了它最大的缺点：当后端在token 有效期内用户Logout或者更改它的权限的话，不会立即生效，如果没有增加额外的处理逻辑，则一般需要等到有效期过后才可以。

### 性能问题

JWT 的卖点之一就是加密签名，由于这个特性，接收方得以验证 JWT 是否有效且被信任。但是大多数 Web 身份认证应用中，JWT 都会被存储到 Cookie 中，这就是说你有了两个层面的签名。为此，你需要花费两倍的 CPU 开销来验证签名。对于有着严格性能要求的 Web 应用，这并不理想，尤其对于单线程环境。

## 区别

### 1.session和cookie区别：

·   数据存放位置不同：Session数据是存在服务器中的，cookie数据存放在浏览器当中。

·   安全程度不同：cookie放在服务器中不是很安全，session放在服务器中，相对安全。

·   性能使用程度不同：session放在服务器上，访问增多会占用服务器的性能；考虑到减轻服务器性能方面，应使用cookie。

·   数据存储大小不同：单个cookie保存的数据不能超过4K，session存储在服务端，根据服务器大小来定。

### 2.token和session区别：

·   token是开发定义的，session是http协议规定的；

·   token不一定存储，session存在服务器中；

·   token可以跨域，session不可以跨域，它是与域名绑定的。

# 10、Cookie 相关首部字段



Cookie用于用户识别及状态管理，为Cookie提供服务的首部字段有：

| 首部字段名     | 说明                                 | 首部类型         |
| -------------- | ------------------------------------ | ---------------- |
| **Set-Cookie** | **开始状态管理所使用的 Cookie 信息** | **响应首部字段** |
| Cookie         | 服务器接收到的 Cookie 信息           | 请求首部字段     |

当服务器准备管理客户端状态的时候，会告知各种信息：

```http
Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;
```



Cookie 相关的首部字段有：

1. **expires**

   指定浏览器可发送Cookie的有效期。当省略 expires 属性的时候，其有效期仅限于维持浏览器会话期间。

   另外，一旦 Cookie 从服务器发送至客户端，服务器就不存在可以显示删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。

2. **path**

   默认为 /，就是根目录。**子路径页面能够访问父路径页面的 Cookie**。兄弟路径页面之间的 Cookie 不能互相访问

3. **domain**

   可以访问该 Cookie 的域名。

   而跨域访问，如域A为[http://t1.test.com](https://link.zhihu.com/?target=http%3A//t1.test.com)，域B为[http://t2.test.com](https://link.zhihu.com/?target=http%3A//t2.test.com)，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.[http://test.com](https://link.zhihu.com/?target=http%3A//test.com)；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为[http://t2.test.com](https://link.zhihu.com/?target=http%3A//t2.test.com)。

4. **secure**
   Cookie 的 secure 属性用于限制 Web 页面**仅在 HTTPS 安全连接时，才可以发送 Cookie**。

   发送 Cookie 时，指定 secure 属性的方法如下：

   ```http
   Set-Cookie:name=value; secure
   ```

5. **HttpOnly**
   Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使得 **JavaScript 脚本无法获取 Cookie**。其主要目的是为了防止跨站脚本攻击（XSS，Cross-site scripting）对 Cookie 的信息窃取。

   指定发送 HttpOnly 属性的 Cookie 的方法如下所示：

   ```http
   Set-Cookie:name=value; HttpOnly
   ```

# 12. TCP三次握手四次挥手机制及原因

```
三次握手：

第一次握手：客户端发送syn包(syn=1，seq=x)到服务器，并进入SYN_SENT状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。


四次挥手:

与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。
第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。
```



## 位码即tcp标志位

有6种标示：

① SYN(synchronous建立联机)；

② ACK(acknowledgement 确认)

③ PSH(push传送)

④ FIN(finish结束)

⑤ RST(reset重置)

⑥ URG(urgent紧急)

Sequence number(顺序号码) //Acknowledge number(确认号码)

## 三次握手

{% asset_img  9.png %}

**为什么需要三次握手，两次行不行？**

第一种解释： 假设是两次握手，客户端刚开始发送第一个建立连接的请求，但是由于该请求在某一个路由器中停留时间过长，客户端一段时间没收到服务器的响应消息，就会再发一个建立连接的请求，这个请求达到服务器，并成功建立连接，之后数据传输完成，关闭连接。这时候先前发送的第一个建立连接的请求，终于通过网络传到了服务器，服务器收到请求，返回一个数据包，并立即打开连接，这是客户端已经关闭了，对服务端的数据包不予理睬，这样就会导致服务端资源的浪费。

第二种解释： 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。

**为什么不能四次握手？**

四次握手的流程：

1. 客户端发送：SYN=1,ACK=0,seq=x 
2. 服务端收到客户端消息，发送：ACK = 1, 确认号=x+1,seq=y 
3. 服务端发送同步建立连接，发送：SYN=1，确认号=x+1，seq = w 
4. 客户端收到发送：ACK=1，确认号=w+1,seq = x+1 

在这个过程中，显然第二步和第三步可以合并，不需要单独发送一个 SYN

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出`FIN`报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回`ACK`报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了`FIN`报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。



## 四次挥手

{% asset_img  10.png %}

服务端在收到客户端断开连接`Fin`报文后，并不会立即关闭连接，而是先发送一个`ACK`包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送`FIN`报文断开连接，因此需要四次挥手

既然握手的时候，服务端发送的两个请求可以合并，那么**释放连接的时候，是否也能合并，只需三次挥手呢**？

我们的回答是不能够，因为当服务器收到客户端关闭连接的请求的时候，服务端可能还在继续发送数据，但是他又必须先给客户端一个回应，说我收到了请求。等服务端的数据发送完毕之后，再发一个数据包说我已经可以关闭请求了。客户端收到之后再作出回应。

## 客户端为什么要有TIME-WAIT阶段？

防止最后一个数据包丢失而导致服务器接收不到，一段时间后服务器会重新发送第三个数据包。如果此时客户端已经关闭了，则收不到第三个数据包，服务端也就无法正常关闭了。

# 13、TCP/UDP 以及他们的区别

## TCP

TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流

## UDP

UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。




| TCP                                                          | UDP                                        |
| ------------------------------------------------------------ | ------------------------------------------ |
| 面向连接，是指发送数据之前必须在两端建立TCP连接，连接方式为三次握手 | 不面向连接，即发送数据前不需要先建立链接； |
| 可靠传输，流量控制与拥塞控制                                 | 不可靠传输，尽最大努力交付                 |
| 传输方式上以字节流的形式传输                                 | 以报文形式传输                             |
| 只能是一对一通信                                             | 支持一对一、一对多、多对多、多对一交互通信 |
| 最小20字节，最多60字节                                       | 首部开销较小，只有 8 字节                  |
| 适用于要求可靠传输的应用                                     | **适用于实时应用，如视频会议、直播等**     |

# 14. localStorage、sessionStorage、Cookie

共同点：都是保存在浏览器端，同源限制。

区别：
(1) cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递
 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存

(2) 存储大小限制也不同
 cookie数据不能超过4k
 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大（实际上指键值与键共10M）

(3) 数据有效期不同
 sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；
 localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；
 cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭;

(4) 作用域不同
 sessionStorage在不同的浏览器窗口不共享，即使是同一个页面；
 localStorage 在所有同源窗口中都是共享的；
 cookie也是在所有同源窗口中都是共享的

# 15. Etag 是怎么计算的，怎么传递的



使用 hash [算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)进行编码，在响应头部里面的 Etag 字段进行传递

## **ETag简介**

ETag是URL的tag，用来标示URL对象是否改变。这样可以应用于客户端的缓存：服务器产生ETag，并在HTTP响应头中将其传送到客户端，服务器用它来判断页面是否被修改过，如果未修改返回304，无需传输整个对象。



# 16. 扫码登录如何实现



扫码登陆要求已经用户在手机端登录

1. 用户在浏览器点击扫码登录，浏览器向服务端发送一个请求，服务端生成一个唯一 id，并将这个 id 写入二维码并且返回这个二维码给浏览器 
2. 浏览器收到之后，开始带上这个 id 轮询后台提供的一个接口，判断用户是否扫码并确认登陆了 
3. 用户拿出手机扫描二维码，得到这个 id，并确认登陆，然后会将用户信息和 id 传给服务器 
4. 服务器拿到用户信息 和 id 之后，写入数据库 
5. 这时候服务器轮询就会得到结果，说明用户已经确认登陆，并且得到服务器返回的 token 和用户信息。



# 17、TCP/IP、OSI七层模型、WebSocket

{% asset_img  8.png %}

## TCP/IP理解

TCP/IP，**传输控制协议**/**网际协议**，是指能够在多个不同网络间实现信息传输的协议簇

- TCP（传输控制协议）

一种面向连接的、可靠的、基于字节流的传输层通信协议

- IP（网际协议）

用于封包交换数据网络的协议

TCP/IP协议不仅仅指的是`TCP`和`IP`两个协议，而是指一个由`FTP`、`SMTP`、`TCP`、`UDP`、`IP`等协议构成的协议簇，

只是因为在`TCP/IP`协议中`TCP`协议和`IP`协议最具代表性，所以通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols）

## TCP/IP划分

TCP/IP协议族按层次分别了五层体系或者四层体系

五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层

五层协议的体系结构只是为介绍网络原理而设计的，**实际**应用还是 TCP/IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层

 **应用层**

`TCP/IP` 模型将 `OSI`参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务

如：`FTP`、`Telnet`、`DNS`、`SMTP` 等

**传输层**

该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能

传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）

其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输

**网络层**

负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机

在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送

**数据链路层**

数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧

**物理层**

保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境



## OSI理解

OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架

`OSI`将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰

## OSI七层

<% asset_img OSI.png %>

1. **应用层**：为用户提供常用的应用程序，每个网络应用对应着不同的协议。例如文件运输访问和管理，电子邮件等。HTTP SMTP
2. **表示层**：主要负责数据格式的转换，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取；数据加密
3. **会话层**：负责网络中两节点的建立，在数据传输中维护计算机网络中两台计算机之间的通信连接，并决定何时终止通信（建立或解除与其他接点的联系）
4. **传输层**：实现两个用户进程间端到端的可靠通信，处理数据包的错误等传输问题 TCP UDP
5. **网络层**：逻辑地址寻址，实现不同网络之间的路径选择 （为数据包选择路由） IP ARP
6. **数据链路层**：建立逻辑连接、进行硬件地址寻址
7. **物理层**：主要是物理介质传输媒介（网线或者是无线），以二进制数据形式在物理媒体上传输数据



## OSI 参考模型与 TCP/IP 参考模型区别?

相同点：

- OSI 参考模型与 TCP/IP 参考模型都采用了层次结构
- 都能够提供面向连接和无连接两种通信服务机制

不同点：

- OSI 采用的七层模型； TCP/IP 是四层或五层结构
- TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分
- OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP/IP 参考模型作为一种简化的分层结构是可以的
- TCP/IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 `OSI` 设想中的应用程序维度的分层是无法实现的



## WebSocket

WebSocket，是一种网络传输协议，位于`OSI`模型的应用层。可在单个`TCP`连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅

客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输

{% asset_img  websocket.png %}

从上图可见，`websocket`服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据

而在`websocket`出现之前，开发实时`web`应用的方式为轮询

不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果

轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 `CPU`资源

## WebSocket特点

### 全双工

通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合

例如指 A→B 的同时 B→A ，是瞬时同步的

### 二进制帧

采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比`http/2`，`WebSocket`更侧重于“实时通信”，而`HTTP/2` 更侧重于提高传输效率，所以两者的帧结构也有很大的区别

不像 `HTTP/2` 那样定义流，也就不存在多路复用、优先级等特性

自身就是全双工，也不需要服务器推送

### 协议名

引入`ws`和`wss`分别代表明文和密文的`websocket`协议，且默认端口使用80或443，几乎与`http`一致

```http
ws://www.chrono.com
ws://www.chrono.com:8080/srv
wss://www.chrono.com:445/im?user_id=xxx
```

### 握手

`WebSocket`也要有一个握手过程，然后才能正式收发数据

客户端发送数据格式如下：

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

- Connection：必须设置Upgrade，表示客户端希望连接升级
- Upgrade：必须设置Websocket，表示希望升级到Websocket协议
- Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接
- Sec-WebSocket-Version ：表示支持的Websocket版本

服务端返回的数据格式：

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat
```

- HTTP/1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接
- Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要

### 优点

- 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
- 更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
- 保持连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
- 更好的二进制支持：定义了二进制帧，更好处理二进制内容
- 支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
- 更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率

## WebSocket应用场景

- 弹幕
- 媒体聊天
- 协同编辑
- 基于位置的应用
- 体育实况更新
- 股票基金报价实时更新

# 18、HTTP请求方式

1. GET：请求指定的页面信息，并返回实体主体。
2. HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
3. POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 
4. PUT：从客户端向服务器传送的数据取代指定的文档的内容。 
5. DELETE：请求服务器删除指定的页面。 
6. CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 
7. OPTIONS：允许客户端查看服务器的性能。 
8. TRACE：回显服务器收到的请求，主要用于测试或诊断。

# 19、GET 和 POST 的区别

两者本质上都是 TCP 链接

1. get 参数通过 url 传递，post 放在请求体 (request body) 中。 
2. get 请求在 url 中传递的参数是有长度限制的，而 post 没有。 
3. get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。 
4. get 请求只能进行 url 编码，而 post 支持多种编码方式。 
5. get 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。 
6. get 产生一个 TCP 数据包；post 产生两个 TCP 数据包。
   对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；
   而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。



# 20、浏览器从输入URL到页面渲染的整个流程

1. **DNS 解析**
2. **TCP 连接**
3. **发送 HTTP 请求**
4. **服务器处理请求并返回 HTTP 报文**
5. **浏览器解析渲染页面**
6. **连接结束**



## 1. 首先对域名进行DNS解析：

- 查询浏览器是否缓存了该域名的IP地址 
- 查询hosts文件中是否存在该域名的IP地址 
- 查询本地DNS服务器（自己手动设置的DNS服务器）是否存在该域名的IP地址 
- 本地DNS服务器向根DNS服务器（13个）发送请求，进行查询 

## 2. 查询到IP地址之后，浏览器开始与服务器建立TCP连接，三次握手：

{% asset_img  29-1.png %}

## 3. 浏览器发出HTTP请求

{% asset_img  29-2.png %}

```
GET /index.html HTTP/1.1
Host: www.sillywa.com
Connection: Close
Cookie: 123456
```

请求由应用层传入传输层，TCP对发出的数据进行处理，如果数据量较大，对数据进行分包，并给每个包标记序号，加上TCP头部（源端口号、目标端口号），总共大小不得超过1480字节；TCP将TCP包交给网络层进行处理，IP在TCP包头部加上IP头部（源IP地址、目标IP地址），IP头部通常20字节，数据包的大小不得超过1500字节；数据包交给数据链路层进行处理，数据链路层将数据包封装成帧，加上源MAC地址和下一个路由器的MAC地址，添加帧首部标记和帧结束标记，然后交给物理层进行传输。物理层将数据帧转为电信号发送出去

## 4. 服务端响应

## 5. 浏览器渲染

浏览器渲染是指浏览器请求下载资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户界面的整个过程。用户看到页面实际上可分为两个阶段：页面内容加载完成和页面资源加载完成，分别对应 `DOMContentLoaded`和`load`。两者的区别如下

- **DOMContentLoaded: DOM渲染完成执行，此时样式表、图片、视频还可能没有加载完成** 
- **load：页面全部资源加载完成才会执行，包括图片、视频** 

浏览器渲染只要包括以下五个步骤：

{% asset_img  29-3.jpg %}

将HTML解析成DOM树 

处理CSS标记，构建层叠样式表模型CSSOM 

将**DOM和CSSOM合并成渲染树**（Render Tree） 

计算**渲染树中每个DOM元素的坐标和大小**，它被称作为布局layout。浏览器使用一种**流式处理方法**，只需要一次绘制操作就可以布局所有的元素 

将**渲染树的各个节点绘制到图层**上，这一步叫做绘制 painting。本质上就是填充像素的过程。包括**绘制文字、颜色、图像、边框和阴影**等，也就是一个 DOM 元素所有的可视效果。一般来说，这个**绘制过程是在多个层**上完成的。 

合成：由于DOM元素的绘制是在多个层上进行的，因此在每个层上绘制完成之后，浏览器会将**所有层按照合理的顺序合并成一个图层**，然后显示在屏幕上，对于有位置重叠的元素，这个过程就比较重要了。（z-index）

{% asset_img  29-4.png %}

浏览器渲染的具体流程：

1. 构建DOM树

   遍历文档节点，生成DOM树，需要注意以下几点：

   - DOM树的构建过程中，可能会被CSS和JS的加载而阻塞执行(css加载不会阻塞DOM树的解析, css加载会阻塞DOM树的渲染, css加载会阻塞后面js语句的执行)
   - display:none的元素也会在DOM树中 
   - 注释也会在DOM树中 
   - script标签也会在DOM树中 

2. 构建CSSOM

   每个CSS文件都被拆分成一个 StyleSheet 对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象，在这个过程中需要注意的是：

   - CSS解析可以与DOM解析同时进行 
   - CSS解析与script的执行互斥 
   - 在Webkit内核中进行了script执行优化，只有在JS访问CSS时才会发生互斥 

3. 构建Render Tree

   浏览器从DOM树的根节点开始遍历每一个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。需要注意的是：

   - Render Tree 和 DOM Tree并不完成对应 
   - display:none的元素并不在Render Tree当中 
   - visibility:hidden的元素在RenderTree中 

4. 渲染树布局

   生成渲染树之后，还是没办法显示在屏幕上，渲染到屏幕上还需要获得个节点的位置信息。这就需要布局的处理了。

   布局会定位DOM元素的坐标和大小。

   布局会从DOM元素的根节点开始遍历，由于渲染树的每一个节点都是一个 Render Object，包含宽高、位置、背景色等信息。所以浏览器就通过这些样式信息来确定每个节点在页面上的确切大小和位置，布局阶段的输出就是盒子模型，它会精确捕获每个元素在屏幕内的确切位置和大小。需要注意的是：

   - float元素，absolute元素，fixed元素会发生位置偏移 
   - 我们常说的脱离文档流，其实就是脱离 Render Tree 

5. 渲染树绘制

   在绘制阶段，浏览器会遍历渲染树，调用渲染器的`paint()`方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。

#### 浏览器渲染过程中遇到JS文件怎么处理

- 渲染过程中，如果遇到 script 标签就会停止渲染，执行里面的JS代码。**JS的加载、解析与执行会阻塞DOM的构建**（将script放在底部的原因） 
- **样式放在head中仅仅是为了更快的解析CSS，保证更快的首次渲染**。 

#### 回流（重排）和重绘（reflow和repaint）

- 回流：对DOM元素的修改引发DOM元素的几何尺寸发生变化（比如修改元素的宽高，隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（重排） 
- 重绘：当我们对DOM的修改导致了样式的变化（比如修改了颜色或者背景颜色）却并未影响其几何属性，浏览器不需要重新计算元素的几何属性，直接为该元素绘制新的样式（跳过了重排的环节）。 

当网页生成的时候，浏览器至少会渲染一次。在用户访问的过程中还会不断重新渲染。重新渲染会导致回流或者重绘。回流必定会引发重绘，但是重绘未必引发回流。不断的重绘和回流会影响页面的性能。回流的成本也远高于重绘

#### 常见引发回流和重绘的操作

会使任何元素的几何属性发生变化的操作（如元素的位置和尺寸），都会触发回流。

- 添加或删除可见的DOM元素 
- 元素尺寸的改变：边距、边框、宽高 
- 内容变化，比如用户在input中输入文字 
- 浏览器窗口尺寸的改变——resize事件 
- 计算 offsetWidth 和 offsetHeight 属性 

常见引起重绘的操作：color,background,border-style

#### 减少reflow与repaint

- 避免逐个修改节点样式，尽量一次修改：使用 DocumentFragment将需要多次修改的DOM元素缓存之后，最后一次性append到真是的DOM中 
- 使用 transform做形变和位移可以减少 reflow 
- CSS选择符避免节点层级过多 
- 避免多次读取某些属性 

#### 提升为合成层

**某些特殊的渲染层会被认为是合成层**（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。

每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责**输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上**，此时，我们的页面也就展现到了屏幕上。

**渲染层提升为合成层有一个先决条件，该渲染层必须是 SelfPaintingLayer**（基本可认为是 NormalPaintLayer）

NormalPaintLayer:

- 根元素 
- 有明确定位的元素（relative、fixed、sticky、absolute） 
- 透明的（opacity 小于 1） 
- 有 CSS transform 属性（不为 none） 

合成层简单来说有以下好处：

- 合成层的位图会交由 GPU 进行处理，比 CPU 处理快 
- 当需要 repaint 时，只会 repaint 本身，不会影响其他的层级 
- 对于 transform 和 opacity 效果，不会触发 layout 和 paint 

**合成层的好处是不会影响到其他元素的绘制**，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。

**提升合成层的最好方式是使用 CSS 的 \*will-change\* 属性**。从上一节合成层产生原因中，可以知道 **will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层**。

对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：

```
#target {
  transform: translateZ(0);
}
```

# 21、浏览器的同源策略

一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。

**同源政策主要限制了三个方面**
第一当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
第二当前域下的 js 脚本不能够操作访问其他域下的 DOM。
第三当前域下 ajax 无法发送跨域请求。

# 22、跨域方法

1.  通过jsonp跨域
2. document.domain + iframe跨域
3.  location.hash + iframe
4. window.name + iframe跨域
5.  postMessage跨域
6.  跨域资源共享（CORS）
7.  nginx代理跨域
8. nodejs中间件代理跨域
9.  WebSocket协议跨域

# 23、前端攻击



## XSS攻击(cross-site script)

1. XSS攻击形式：

   主要是通过html标签注入，篡改网页，插入恶意的脚本，前端可能没有经过严格的校验直接就进到数据库，数据库又通过前端程序又回显到浏览器

2. 攻击的目的：

   攻击者可通过这种方式拿到用户的一些信息，例如cookie 获取敏感信息，甚至自己建网站，做一些非法的操作等；或者，拿到数据后以用户的身份进行勒索，发一下不好的信息等。

3. 攻击防御

   方法1：cookie中设置 HttpOnly 属性

   方法2：首先前端要对用户输入的信息进行过滤，可以用正则，通过替换标签的方式进行转码或解码，例如<> 空格 & '' ""等替换成html编码

## CSRF攻击(cross site request forgery,跨站请求伪造)

1. CSRF攻击形式：

   CSRF也是一种网络攻击方式，通过伪装成站点用户进行攻击，

   csrf攻击形式：攻击者盗用用户的身份信息，并以用户的名义进行发送恶意的请求等，例如发邮件，盗取账号等非法手段

1. 攻击防御： 

- 验证HTTP Referer字段 
- 在请求地址中添加token并验证 
- 在HTTP头中自定义属性并验证

# 24、浏览器缓存机制

浏览器缓存分为：强缓存和协商缓存

在浏览器第一次发起请求时，本地无缓存，向 web 服务器发送请求，服务器端响应请求，浏览器端缓存。在第一次请求时，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个 Etag，并发送给客户端。



## 强缓存 Expires 和 Cache-Control 的使用

强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的，用来表示资源的缓存时间。强缓存中，普通刷新会忽略它，但不会清除它，需要强制刷新。浏览器强制刷新，请求会带上`Cache-Control:no-cache` 和 `Pragma:no-cache`

**Expires**

Expires 的值是一个绝对时间的 GMT 格式的时间字符串。比如 Expires 值是：`expires:Fri, 14 Apr 2017 10:47:02 GMT`。这个时间代表这这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。

缺点：
由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，误差很大，就会导致缓存混乱。

**Cache-Control**

Cache-Control 主要是利用该字段的 `max-age` 值来进行判断，它是一个相对时间，例如`Cache-Control:max-age=3600`，代表着资源的有效期是 3600 秒。

Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。



## 协商缓存

协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。

**Etag 和 If-None-Match**

当浏览器第一次请求一个资源时,服务端返回的状态码为200,同时HTTP相应头会有一个Etag字段,存放着服务器端生成的一个序列值.

{% asset_img  etag1.png %}

浏览器第二次请求上次请求过的url时，浏览器会在HTTP请求头添加一个If-None-Match的标记，用来询问服务器该文件有没有被修改。

{% asset_img  etag2.png %}

如果服务器的资源没有变化,Etag字段没有被修改依然与If-None-Match的值保持一致,则请求自动返回304状态,使用浏览器缓存.如果不一致,则说明资源被更改,则重新去下载新的资源.

**etag缺点**

与`Last-Modified`不一样的是，当服务器返回 304 (Not Modified) 的响应时，由于`Etag`重新生成过，response header 中**还会把这个`Etag`返回**，即使这个`Etag`跟之前的没有变化。

 **Last-Modify / If-Modify-Since**

浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-Modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。如果命中缓存，则返回304，并且不会返回资源内容，**并且不会返回Last-Modify。**

## 缺点

缓存有缺点

比如说，设置了**expires**，GMT格式，但是浏览器的时间可以改变

因此就通过**cache-control**返回一个相对时间来。但是假如说资源并没有更新，但是强缓存时间过期了，那就需要重新拉去资源

因此就有了**last-modified**但是last-modified的时间单位是s，当1s内有资源修改，那浏览器返回的最后修改时间和上次的修改时间相同，那就不会重新拉取资源

因此推出了**etag**，通过比对资源内容来判断是否修改

# 25、进程和线程的关系

**进程是资源分配的最小单位,线程是CPU调度的最小单位。**

**根本区别**：进程是资源分配最小单位，线程是程序执行的最小单位。 计算机在执行程序时，会为程序创建相应的进程，进行资源分配时，是以进程为单位进行相应的分配。每个进程都有相应的线程，在执行程序时，实际上是执行相应的一系列线程。

**地址空间**：进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段；线程没有独立的地址空间，同一进程的线程共享本进程的地址空间。

**资源拥有**：进程之间的资源是独立的；同一进程内的线程共享本进程的资源。

**执行过程**：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

线程是处理机调度的基本单位，但是进程不是。由于程序执行的过程其实是执行具体的线程，那么处理机处理的也是程序相应的线程，所以处理机调度的基本单位是线程。

**系统开销**：进程执行开销大，线程执行开销小。

```js
// 使用async/await获取成功的结果

// 定义一个异步函数，3秒后才能获取到值(类似操作数据库)
function getSomeThing(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve('获取成功')
        },3000)
    })
}

async function test(){
    let a = await getSomeThing();
    console.log(a)
}
test(); // 3秒后输出：获取成功

```



# 26、DNS、DNS查询过程

## 是什么？

DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器

简单来讲，`DNS`相当于一个翻译官，负责将域名翻译成`ip`地址

- IP 地址：一长串能够唯一地标记网络上的计算机的数字
- 域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识

{% asset_img  DNS是什么.png %}

## 域名

域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名...

{% asset_img  域名.png %}

例如`www.xxx.com`，`www`为三级域名、`xxx`为二级域名、`com`为顶级域名，系统为用户做了兼容，域名末尾的根域名`.`一般不需要输入

## 查询方式

DNS 查询的方式有两种：

- 递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案

{% asset_img  DNS递归查找.png %}

- 迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求

{% asset_img  DNS迭代查找.png %}

## 域名缓存

在域名服务器解析的时候，使用缓存保存域名和`IP`地址的映射

计算机中`DNS`的记录也分成了两种缓存方式：

- 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- 操作系统缓存：操作系统的缓存其实是用户自己配置的 `hosts` 文件

## 查询过程

解析域名的过程如下：

- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
- 若没有命中，则继续搜索操作系统的 DNS 缓存
- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

流程如下图所示：

{% asset_img  DNS查询过程.png %}

# 27、计算机网络中MAC地址与IP地址

## MAC地址

连入网络的每一个计算机都会有网卡接口，每一个网卡都会有一个唯一的地址，这个地址就叫做 MAC 地址。计算机之间的数据传送，就是通过 MAC 地址来唯一寻找、传送的。MAC地址 由 48 位二进制数所构成，在网卡生产时就被唯一标识了。

## IP地址

IP协议，它所定义的地址，我们称之为**IP地址**。每一台想要联网的计算机都会有一个IP地址。这个IP地址被分为两部分，前面一部分代表**网络部分**，后面一部分代表**主机部分**。并且网络部分和主机部分所占用的二进制位数是不固定的。

## 区别

MAC唯一且不可变的，IP地址与域名通常是唯一但可变的。

IP地址与域名是对应转换关系，就像名字与身份证的关系，IP是身份证号，具有唯一性，但不方便记忆，域名则是身份证号对应的姓名，主要为了方便记忆。域名通过DNS服务转换对应ip地址。

IP地址与MAC地址也是具有对应转换关系的，IP地址是网络地址，数据的传输最终是需要由物理层处理，而MAC地址是唯一且不可变的物理地址。

IP地址与MAC地址本质上不具有对应转换关系，但是可以理解为存在动态的对应关系，两者均是唯一地址，IP是动态的。

**对一台设备来说，mac地址是全球唯一的，而ip和域名是可变的。**

# 28、HTTP与TCP的区别和联系

TCP对应于传输层，HTTP对应于应用层，从本质上来说，二者没有可比性。

Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。

TCP是底层协议，定义的是数据传输和连接方式的规范。
 HTTP是应用层协议，定义的是传输数据的内容的规范。
 HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP就一定支持TCP。

# 29、TCP的流量控制与拥塞控制？

## 拥塞控制与流量控制的区别

- **流量控制** 是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止丢失数据包的。
- **拥塞控制** 拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况

## 流量控制

TCP 利用**滑动窗口**实现流量控制的机制， 而滑动窗口大小是通过TCP首部的窗口大小字段来通知对方。

{% asset_img TCP首部.png %}

在TCP协议的头部信息当中，有一个16位字段的窗口大小，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。**这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。** 不过，当接收端这个接收缓冲区面临数据溢出时，窗口大小的值就会随之设置成一个更小值，告诉发送端要控制一下发送的数据量了。 发送端接收到接收端的窗口变化指示后，就会对数据发送量进行调整，从而形成一个完整的流量控制。

流量控制的具体操作就是：接收端会在确认应答发送ACK报文时，将自己的即时窗口大小rwnd（receiver window）填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值进而改变自己的发送速度。

{% asset_img 流量控制.png %}

如上图所示，主机B接收到了一个1-1000序列号的数据包以后，返回一个ACK给发送端，并且告诉发送端它的窗口大小为3000，意味着发送端还能发送3000个字节的数据。 主机A收到指示后，继续发送数据，直到主机B收到3001-4000的数据段后其接收缓冲区满了，主机B的返回窗口大小为0，让主机A要暂停发数据了。

就是这样一个流程，可以防止发送端一次发送过大的数据导致接收端无法处理的情况。

那么另外一个问题来了：**发送端停止发送数据后，什么时候可以继续发送数据呢？** 我们继续看上图，答案就是等接收端处理完了缓冲区的数据后发送一个**窗口更新**的数据包通知，发送端才可以继续根据窗口大小发送数据。 但是如果发送端在重发超时的时间内都没有收到窗口更新的通知或者窗口更新的包丢失了，就没法正常通信了，那怎么办呢？

TCP为每一个连接设有一个**持续计时器(persistence timer)。** 只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测数据段（这个数据段只包含一个字节），那么收到这个报文段的一方就重新设置持续计时器。

所以发送端会定时向接收端发送一个 **窗口探测** 的数据段，这目的是为了获取最新的窗口大小信息。

就这样，完成了TCP流量控制的整个过程。

## 拥塞控制

### 什么是拥塞控制？

我们都知道计算机网络中的资源是有限的。某段时间内网络中对资源的需求超过了网络中的可用部分，而导致网络性能下降的情况就是拥塞。 通俗点说就是发送的数据包太多网络中的设备处理不过来，而导致网络性能下降的情况。

### TCP 为什么要进行拥塞控制

网络中的路由器会有一个数据包处理队列，当路由器接收到的数据包太多而一下子处理不过来时，就会导致数据包处理队列过长。此时，路由器就会无条件的丢弃新接收到的数据封包。 这就会导致上层的 TCP 协议以为数据包在网络中丢失，进而重传这些数据包，而路由器又会丢弃这些重传的数据包，如此以往，就会导致网络性能急剧下降，引起网络瘫痪。因此，TCP 需要控制数据包发送的数量来避免网络性能的下降。

### 拥塞控制原理

有了TCP的滑动窗口控制，收发主机之间即使不再以一个“段”为单位，而是以一个“窗口”为单位发送确认应答信号，所以发送主机够连续发送大量数据包。然而，**如果在通信刚开始的时候就发送大量的数据包，也有可能会导致网络的瘫痪。**

在拥塞控制中，发送方维持一个叫做**拥塞窗口cwnd**（congestion window）的状态变量。**拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化**。 发送窗口取拥塞窗口和接收端窗口的最小值，避免发送接收端窗口还大的数据。

拥塞控制使用了两个重要的算法： **慢启动算法**， **拥塞避免算法**。

**慢启动算法**： 慢启动算法的思路是，不要一开始就发送大量的数据，先试探一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。慢算法中，**每个传输轮次后将 cwnd 加倍**。 举个例子：一开始发送方设置cwnd=1（为方便理解，这里用报文段的个数作为窗口大小的单位），然后每经过一个传输轮次，cwnd都发加倍，比如1, 2, 4, 8...指数增长 所以，这里的慢启动，不是指拥塞窗口增长慢，而是相对于一开始就上来传输大窗口的数据要显得慢。

{% asset_img  慢启动.png %}

当然，cwnd 的大小肯定不可能一直以这种指数的方式增长下去，要不然很快就会增长到引起网络崩溃的程度了。所以，经过一定时间或条件，我们就要换成**拥塞避免算法**来发送数据。

**拥塞避免算法**：拥塞避免算法也是逐渐的增大 cwnd 的大小，只是采用的是**线性增长** 而不是像慢启动算法那样的指数增长。 具体来说就是每个传输轮次后将 cwnd 的大小加一（加法增大），如果发现出现网络拥塞的话就按照上面的方法重新设置ssthresh的大小（乘法减小，原来的二分之一）并从cwnd=1开始重新执行慢开始算法。

{% asset_img  拥塞避免.png %}

## 慢启动算法和拥塞避免算法结合：

问题：在拥塞控制中， 慢启动算法 和 拥塞避免算法 是怎么配合使用的呢？

像上面所说，慢启动算法下的cwnd大小是指数增长，所以不能任 cwnd 任意增长，所以我们引入一个慢启动门限（ssthresh）的阈值来控制 cwnd 的增长。

ssthresh的作用是：

- 当cwnd < ssthresh时，使用慢开始算法。
- 当cwnd > ssthresh时，改用拥塞避免算法。
- 当cwnd = ssthresh时，慢开始与拥塞避免算法随机

还有一个问题就是这个 ssthresh 是怎么设置的呢？ **TCP/IP 中规定无论是在慢开始阶段还是在拥塞避免阶段，只要发现网络中出现拥塞（没有按时收到确认），就要把ssthresh设置为此时发送窗口的一半大小**（不能小于2）。

{% asset_img  拥塞控制例子.png %}

一开始把ssthresh初始值设置成16，开始慢启动增加拥塞窗口cwnd，直到cwnd=16 停止慢启动，开始拥塞避免算法。

使用拥塞避免算法线性增加cwnd，直到cwnd=24，这时候网络出现拥塞（ACK确认信号没有及时到达），把ssthresh设置成原来的一半，也就是ssthresh=12，同时把cwnd设为1。

重新开始慢启动，直到cwnd到达ssthresh=12，然后执行拥塞避免算法进行加法增大，直到遇到网络拥塞，把ssthresh调成原来的一一半。

如此反复动态计算cwnd，以达到拥塞控制的目的。

## 快重传 VS 超时重传

TCP 的可靠传输的原理就是超时重传机制，而重发机制有两种：**超时重传机 和 快重传**

**TCP超时重传机制**，结合上面说的**慢启动**和**拥塞避免**使用就是发送完数据后开始倒计时，如果在**重发超时内**没有收到对接收方发来的ACK的话就去执行上述的**乘法减小过程（设置sstresh为原来一半）** 并重新开始慢开始算法，重新发送数据。

**TCP快重传**， 则是允许发送方再连续收到**3 个重复的确认**后就可以开始执行乘法减小过程而不必再等待重发超时时间。这就需要接收方每收到一个**失序**的报文段就立即发出重复确认以让发送发及早知道有报文段丢失，而不是等待自己发送数据的时候进行捎带确认。

{% asset_img  重复确认.png %}

如图，由于发送端不必等待每个数据段都确认才能继续发送，而是以一个窗口为单位发送数据，所以就算主机A发送的1001-2000序列号数据段丢失，主机A依然会继续发剩下的窗口大小数据，而此时主机B发现1001-2000数据丢失，它会每次收到其他序列号的数据包，都返回一个序列号2000的ACK，以此明确通知主机A，当主机A收到**三次**2000的ACK知道丢失了1001-2000数据包，就需要重传1001-2000的数据包了。 以此达到哪怕没到重发超时时间，都能快速重传的目的。

## 快恢复

**快恢复算法是与快重传算法配合使用的一个算法。**

快恢复主要是指，当快重传的时候，发送方快速收到了**3个重复的确认**，因此会认为网络不是拥塞状态，所以在**乘法减小过程（设置sstresh为原来一半）**，会启动 **“拥塞避免”**，而不是TCP超时重发机制的重新启动的**慢启动**

## 总结

总结了TCP协议在传输可靠性的两个重要机制：

- 通过**流量控制**控制发送者的发送速度从而使接收者来得及接收，防止丢包。
- 通过**拥塞控制**就是防止过多的数据注入到网络中，避免网络中的路由器或链路不致过载，导致数据丢失。从而保证了TCP传输的可靠性。

# 30、TCP粘包原因和解决

## 粘包概念及产生原因

### 粘包概念:

- TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。
- 粘包可能由发送方造成，也可能由接收方造成。
- 只有TCP有粘包现象，UDP永远不会粘包
- 粘包不一定会发生

### 粘包原因:

所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。

- 发送端原因: 由于TCP协议本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会**维持一个连接**（Channel），数据在连接不断开的情况下，可以**持续不断地将多个数据包发往服务器**，但是如果发送的网络数据包太小，那么他本身会启用Nagle算法（可配置是否启用）**对较小的数据包进行合并**（基于此，TCP的网络延迟要UDP的高些）然后再发送（超时或者包大小足够）。那么这样的话，服务器在接收到消息（数据流）的时候就**无法区分哪些数据包是客户端自己分开发送的**，这样产生了粘包.
- 接收端原因: 服务器在接收到数据库后，**放到缓冲区**中，如果**消息没有被及时从缓存区取走**，下次在取数据的时候可能就会出现**一次取出多个数据包**的情况，造成粘包现象。

## tcp粘包解决办法

- 在每次使用tcp协议发送数据流时,在开头标记一个数据流长度信息,并固定该报文长度(自定义协议).在客户端接收数据时先接收该长度字节数据,判断客户端发送数据流长度,并只接收该长度字节数据,就可以实现拆包,完美解决tcp粘包问题.



# 31、UDP如何实现可靠传输

基于应用层的可靠传输，udp可靠设计没有万精油，需要根据具体的使用场景。

第一个是重传机制，丢包需要进行重传，可以用ACK也可以用NACK的方式；

第二是重排机制，我们在收到乱序数据一定需要增加一个缓冲区进行数据重排；

第三是超时机制，长时间没收收到对方的回复需要进行重试；

第四，流量控制，在局域网内一般是不考虑这部分，实现起来比较复杂，收益不是那么大。

# 32、CDN

## 简介

CDN（Content Delivery Network）是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。

## 工作原理

CDN之所以快，靠的是多节点、多线路、用缓存。

- **多节点**
  也就是多服务器，在网络各处放置节点服务器，构成在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
- **多线路**
  可以有效避免跨线路互联不互通的问题。
- **用缓存**
  广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。另外，CDN服务器知道源站的资源发生变化后，会通知其它服务器同时更新资源。

## 缺点

### 成本

```
这可能是使用CDN的最重要的缺点。开始使用CDN服务的成本很高，而且它们也有许多隐藏成本。其中包括每次数据传输和千兆字节的成本。高成本来自第三方网络。启动新的CDN网络要求服务器公司从另一家公司获得帮助以安装此类网络。请务必仔细阅读所有条款和条件。

鉴于此，CDN网络往往是能够负担这些成本的大公司的更好选择。在全球范围内维护无用的复制服务器也是不切实际的。
```

### 服务地点

```
如果您的大多数受众群体位于CDN没有服务器的国家/地区，则您网站上的数据可能需要比不使用任何CDN更进一步。
```

### 限制

```
一些组织和国家已阻止流行CDN的域或IP地址。在这种情况下，来自这些组织或国家/地区的受众群体无法访问您的网站，您最终会失去部分流量。
```

### 支持可用性

```
当第三方供应商负责运行CDN时，会出现支持问题。如果出现技术问题，即使很少见，您也无法知道操作员需要多长时间来解决问题并防止再次发生问题。
```

### 失去控制

```
您是否愿意将您的网站文件移交给另一家公司？在决定是否使用CDN之前，您必须考虑这一点。使用CDN意味着第三方会收到有关您的网站和系统的信息。
```

# 33、为啥UDP不会粘包?

**UDP**则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。
他不会对数据包进行合[并发](https://so.csdn.net/so/search?q=并发&spm=1001.2101.3001.7020)送（也就没有Nagle算法之说了），他直接是一端发送什么数据，直接就发出去了，既然他不会对数据合并，每一个数据包都是完整的（数据+UDP头+IP头等等发一次数据封装一次），如果接收方一次没有接受完数据，但是第二次的数据又发送过来，那么就会发生数据丢失问题，原先的数据将会被丢弃。‘’









