---
title: 算法之路
date: 2022-03-18 20:56:59
tags: 数据结构与算法
---

# 时间复杂度的计算

<!-- more -->

## 1. 定义

在进行算法分析时候,语句总的执行次数T(n)是关于问题规模n的函数,进而分型T(n)随着n的变化情况并确定T(n)的数量级.算法的时间复杂度,也就是算法的时间度量记作:T(n)=O(f(n)).它表示随着问题规模n的增大,算法执行时间的增长率和f(n)的增长率相同,称作算法的渐近时间复杂度,简称时间复杂度.其中f(n)是问题规模n的某个函数.

简单来说T(n)代表时间频度：一个算法中语句执行次数称为时间频度

时间复杂度就是：算法的时间复杂度描述的是T(n)的变化规律，计作：T(n) = O(f(n))。

这里用大写的O( )来体现算法时间复杂度的记法,我们称之为大O记法.

## 2. 推导大O阶方法（游戏秘籍三部曲）

1. **用常数1取代运行时间中的所有加法常数。**
2. **在修改后的运行次数函数中，只保留最高阶项。**
3. **如果最高阶项存在且不是1，则去除与这个项乘积的常数。**

## 3. 常数阶

```js
let sum = 0, n = 100  //执行一次
sum = (1 + n) * n / 2  //执行一次
return sum //执行一次
```

这个算法的运行次数是f(n)=3,与n的大小无关
根据推导大O阶的方法,常数项3改为1,即时间复杂度为O(1)
对于分支结构(不含循环结构),无论真或假,执行的次数都是恒定的
不会随着n的变大而发生变化,其时间复杂度也是O(1)

## 4. 线性阶

```js
for(let i=0;i<n;i++){
   /* 这里是时间复杂度为O(1)的程序步骤序列,就是一行一行的,没有循环 */
}
```

关键就是要分析**循环结构的运行情况**
上面这是一个for循环,那么它的时间复杂度又是多少呢?首先循环体就是一个执行一次的循环体,总共执行了n次,那么执行次数就是f(n) =n,启动我们的游戏攻略三部曲知道,时间复杂度就是为O(n).

## 5. **对数阶**

```js
let count=1;
while(count<n){
    count=count*2
}
```

对数阶不是很好理解
每次count都会乘以一个2，他会距离n更近一步
这里详细解释一下
count=1时 1<n count=2 2的一次方
count=2时 2<n count=4   2的二次方
count=4时 4<n count=8   2的三次方
…
到2的x次方大于n的时候 循环就结束了
由2的x次方等于n --> x = logn,时间复杂度为O(logn)
常见的二分查找就是以上思路，时间复杂度为O(logn).

## 6. **平方阶**

```js
for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
     /* 这里是时间复杂度为O(1)的程序步骤序列*/
    }
}
```

由于当i = 0时,内循环执行n此,当n = 1时, 执行了 n - 1 次, …当 i = n-1 时, 执行了1次,所以总的执行次数为:
n + (n -1) +( n -2 ) +… +1 = n(n +1)/2 = n^2/2 + n/2

根据我们的游戏秘籍的三部曲(保留最高阶，去除最高阶不是1的常数项),我们可以分析出来,时间复杂度为 O( n^2 ).

## 7. **常见算法时间复杂度**

{% asset_img 常见时间复杂度.png  %}

# 空间复杂度

空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数

空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)

 空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)

​                 ax=N，则x=logaN，

  空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).

# 常见时间复杂度以及算法的过程(图片)

```html
https://blog.csdn.net/qq_35556064/article/details/82888717?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-9-82888717.nonecase&spm=1018.2226.3001.4187
```

| 排序算法 | 最佳时间复杂度 | 平均时间复杂度 | 最坏时间复杂度  | 稳定性 | 空间复杂度 |
| -------- | -------------- | -------------- | --------------- | ------ | ---------- |
| 选择排序 | O(N^2)         | O(N^2)         | O(N^2)          | 不稳定 | O(1)       |
| 插入排序 | O(N)           | O(N^2)         | O(N^2)          | 稳定   | O(1)       |
| 冒泡排序 | O(N)           | O(N^2)         | O(N^2)          | 稳定   | O(1)       |
| 希尔排序 | O(N)           | O(N^(3/2))     | O(N^S)（1<S<2） | 不稳定 | O(1)       |
| 快速排序 | O(NlogN)       | O(NlogN)       | O(N^2)          | 不稳定 | O(logN)    |
| 堆排序   | O(NlogN)       | O(NlogN)       | O(NlogN)        | 不稳定 | O(1)       |
| 归并排序 | O(NlogN)       | O(NlogN)       | O(NlogN)        | 稳定   | O(N)       |



# 2022-3-18

## 1、链表-反向链表

{% asset_img  反向链表题目.png %}

思路： 

{% asset_img  反向链表常规解题思路图解.png %}

### 正常解法

我的java代码：运用第三个空碗来接住下一次的链表结点，然后每次循环，让前面的结点指向 它前面的结点 【即pre】

{% asset_img  反向链表-常规.png %}

### 递归算法

{% asset_img  反向链表-递归.png %}

head.next.next  -》 因为不能每次都通过尾部【即新链表的头部】的next来找到最新的那个结点，所以直接通过改变中间结点【即当前的参数head】的next【即上一次递归回来的next】的next【这里是上次递归回来的结点的next，要往回指【即目前的参数head】】等于head改变结点的指向。   并且将当前结点【即head的next指向空，不然就变成了循环链表了，细品~】

## 2、 二分法-普通二分查找

{% asset_img  二分法.png %}

二分法要注意的是，while循环的终止条件，如果条件不正确，就可能会漏掉比较两个数的可能性，可能就会出错哦~

# 2022-3-19

## 1、链表-合并两个排序链表

描述

输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。

数据范围： 0 \le n \le 10000≤*n*≤1000，-1000 \le 节点值 \le 1000−1000≤节点值≤1000
要求：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}

{% asset_img  合并两个排序链表.png%}

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode newList = new ListNode(-1);
        ListNode temp = newList;
        if(list1 == null && list2 == null) return null;
        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                newList.next = list1;
                newList = newList.next;
                list1 = list1.next;
            }else{
                newList.next = list2;
                newList = newList.next;
                list2 = list2.next;
            }
        }
        if(list1 == null){
            newList.next = list2;
        }
        if(list2 == null){
            newList.next = list1;
        }
        return temp.next;
    }
}
```



## 2、二分法-旋转数组二分查找

描述

有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。

数据范围：1 \le n \le 100001≤*n*≤10000，数组中任意元素的值: 0 \le val \le 100000≤*v**a**l*≤10000

要求：空间复杂度：O(1)*O*(1) ，时间复杂度：O(logn)*O*(*l**o**g**n*)

示例1

输入：

```
[3,4,5,1,2]
```

返回值：

```
1
```

示例2

输入：

```
[3,100,200,3]
```

返回值：

```
3
```

### 方法一：

和二分法没关系【考虑到了所有情况，但是出发点在全局】

```
1.数组为空

2.部分旋转，例如由（1,2,3,4,5）旋转为（3,4,5,1,2），此时只需要遍历数组，找到当前数比前面的数小的数即可。

3.完全旋转，例如由（1,2,3,4,5）旋转为（1,2,3,4,5），此时第一个数最小。
```

```java
 if(array.length == 0) return 0;
   // 暴力：挨个寻找最小的---前提的数组进行了旋转排序
 for(int i = 0; i < array.length-1; i++){
     if(array[i] > array[i+1]){
       return array[i+1];
     }
 }
 return array[0];//数组没有进行旋转排序，即递增数组
```

### 方法二：

主要就是二分法，但是要考虑 三种情况

```java
int low = 0 ; 
int high = array.length - 1;
int mid = (low + high) / 2;
if(array.length == 0)return 0;
while(low < high){
    if(array[mid] > array[high]){
        low = mid + 1;
    }else if(array[mid] < array[high]){
        high = mid;
    }else{
        high = high - 1;
    }
    mid = (low + high) / 2;
}
return array[mid];
```

```
需要考虑三种情况：
(1)array[mid] > array[high]:
出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。
low = mid + 1
(2)array[mid] == array[high]:
出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边
还是右边,这时只好一个一个试 ，
high = high - 1
(3)array[mid] < array[high]:
出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左
边。因为右边必然都是递增的。
high = mid
```



# 2022-3-21

## 1、链表-链表排序

给定一个节点数为n的无序单链表，对其按升序排序。

### 投机取巧-只替换val值

```java
这里的方法是遍历链表，用遍历到的结点来和后面所有的结点进行比较，然后每一轮下来之后，第一个值就是最小的值。

import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */
    public ListNode sortInList (ListNode head) {
        // write code here
        if(head == null || head.next == null) return head;
        
        ListNode move = head;
        while(move.next != null){
            ListNode temp = move.next;
            while(temp != null){
                if(temp.val < move.val){
                    int m = temp.val;
                    temp.val = move.val;
                    move.val = m;
                }
                temp = temp.next;
            }
            move = move.next;
        }
        return head;
    }
}
```

### 快速排序-要有一个哨兵结点

```java
这个方法是要设置一个头结点，就是哨兵结点【sort.next】。
1、首先将创建头结点和遍历开始结点。 
2、记得要留住当前遍历结点的前一个结点，因为如果当前结点是最小的结点，后续要进行换位置【这个是链表】，所以必须拿到【遍历之后把  pre交给preMin】。
3、进行遍历，先将cur指向当前遍历的结点，然后进行遍历【如果此时没有最小的结点，那就当前就为最小的结点】，当遇到最小的结点时候，记录这个结点，即【preMin = pre， min = cur】，如此循环，直到cur==null。
4、进行到此刻，min已经找到了，剩下的就是交换顺序【刚才的preMin.next = min.next，min.next = sort.next，sort.next = min】，之后继续进行最外层的遍历，直到sort.next == null。
5、返回头的下一个，即 p.next。


public ListNode sortInList (ListNode head) {
    // write code here
    if(head == null || head.next == null) return head;
    ListNode p = new ListNode(-1);
    ListNode sort = p;
    p.next = head;

    while(sort.next != null){
        ListNode cur = sort.next;
        ListNode pre = sort;
        ListNode min = null;
        ListNode preMin = null;

        while(cur != null){
            if(min == null || cur.val < min.val){
                min = cur;
                preMin = pre;
            }
            cur = cur.next;
            pre = pre.next;
        }
        preMin.next = min.next;
        min.next = sort.next;
        sort.next = min;
        sort = sort.next;
    }
    return p.next;
}
```

### 归并排序

```java
1.快慢指针分割链表
2.递归分割
3.合并链表

public ListNode sortInList (ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
 
    return mergeSort(head);
}
 
public ListNode mergeSort(ListNode head) {
    if (head.next == null) {
        return head;
    }
 
    ListNode slow = head, fast = head, pre = null;
    while (fast != null && fast.next != null) {
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    pre.next = null;
    ListNode left = mergeSort(head);
    ListNode right = mergeSort(slow);
    return merge(left, right);
}
public ListNode merge(ListNode left, ListNode right) {
    ListNode dummy = new ListNode(-1);
    ListNode cur = dummy;
    while (left != null && right != null) {
        if (left.val < right.val) {
            cur.next = left;
            left = left.next;
        } else {
            cur.next = right;
            right = right.next;
        }
        cur = cur.next;
    }
    if (left != null) {
        cur.next = left;
    }
    if (right != null) {
        cur.next = right;
    }
    return dummy.next;
}
```

# 2022-3-22

## 1、 斐波那契数列 

### 递归法

```java
递归当在n的值比较大的时候，会进行重复的计算，从而导致，递过去了，一直等着归，浪费了很多时间

public class Solution {
    public int Fibonacci(int n) {
        if( n == 1 || n == 2){
            return 1;
        }
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
```

### 动态规划

```java
简单的动态规划，以一定的空间代价避免代价更大的重复计算的栈空间浪费

public class Solution {
    public int Fibonacci(int n) {
        if(n == 1 || n == 2)  return 1 ;
        int[] a = new int[n+1];
        a[0] = a[1] = 1;
        for(int i = 2; i < n; i++){
            if(a[i-1] != 0 && a[i-2] != 0){
                a[i] = a[i-1] + a[i-2];
            }
        }
        return a[n-1];
    }
}
```

### 动态规划

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 0) return 0;
        int f = 0, g = 1;
        while((--n) != 0){
            g = g+f;
            f = g-f;
        }
        return g;
    }
}
```

## 2、动态规划法-跳台阶

```
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

解析：假设现在6个台阶，我们可以从第5跳一步到6，这样的话有多少种方案跳到5就有多少种方案跳到6，另外我们也可以从4跳两步跳到6，跳到4有多少种方案的话，就有多少种方案跳到6，其他的不能从3跳到6什么的啦，所以最后就是f(6) = f(5) + f(4)；这样子也很好理解变态跳台阶的问题了。
```

```java
public class Solution {
    public int jumpFloor(int target) {
        if(target <= 2) return target;
        int m = 1, n = 2;
        int result = 0;
        for(int i = 2; i < target; i++){
            result = m + n;
            m = n;
            n = result;
        }
        return result;
    }
}
```

## 3、动态规划法-最小化费爬楼梯

```
给定一个整数数组 cost[]，其中 cost[i] 是从楼梯第i个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费.

输入： [1,100,1,1,1,90,1,1,80,1]
返回值： 6

说明：
你将从下标为 0 的台阶开始。
1.支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
2.支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
3.支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
4.支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
5.支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
6.支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。 
```

```java
我发现这几种题型，最重要的就是逆向推理，反过来推，思路就会不一样了。如果从前往后就会没有思路。
假如我们要上 6 层楼，那么 只需要知道 第 5 层或者第 4 层楼的情况，然后再分别分析， 第 5 层和第 4 层的情况，如此反复！！
    
但是这道题还有个小细节就是，每层楼的代价 = 前两层中最小代价的层数代价 + 自己当前的代价，因为如果下次跳的时候是从当前这层跳的，那么就要考虑这层楼的代价。
    
思路： 创建一个新的数组，用来保存 ==》跳到那层楼的最小代价，最后选择最后两层楼中代价最小的一层。从前往后，依次计算。

import java.util.*;

public class Solution {
    public int minCostClimbingStairs (int[] cost) {
        // write code here
        if(cost.length <= 2) return cost[0];
        int[] temp = new int[cost.length];
        temp[0] = cost[0];
        temp[1] = cost[1];
        for(int i = 2; i < cost.length; i++){
            if(temp[i-1] <= temp[i-2]){
                temp[i] = temp[i-1] + cost[i];
            }else{
                temp[i] = temp[i-2] + cost[i];
            }
        }
        if(temp[cost.length-1] < temp[cost.length-2]) return temp[cost.length-1];
        else return temp[cost.length-2];
    }
}


================分割线=================
    
public int minCostClimbingStairs (int[] cost) {
    if (cost.length == 1 || cost.length == 2) return cost[0];
    int first=cost[0],second=cost[1];
    for (int i=2;i<cost.length;i++)
    {
        int temp=second;
        second=Math.min(first+cost[i],second+cost[i]);
        first=temp;
    }
    return first < second ? first : second;
}
```

# 2022-3-23

## 1、动态规划法-不同路径的数目（一）

一个机器人在m×n大小的地图的左上角（起点）。

机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。

可以有多少种不同的路径从起点走到终点？

{% asset_img  不同路径-1.png %}

{% asset_img  不同路径-1-解法图.png %}

```
输入：2,1
返回值：1

输入：2,2
返回值：2
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param m int整型 
     * @param n int整型 
     * @return int整型
     */
    public int uniquePaths (int m, int n) {
        // write code here 
        if(m == 1 || n == 1) return 1;
        int[][] road = new int[m][n];
        for(int i = 0; i < m; i++){road[i][0] = 1;}
        for(int j = 0; j < n; j++){road[0][j] = 1;}
        for(int x = 1; x < m; x++){
            for(int y = 1; y < n; y++){
                road[x][y] = road[x-1][y] + road[x][y-1];
            }
        }
        return road[m-1][n-1];
    }
}
```

## 2、动态规划法-矩阵的最小路径和

给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。

{% asset_img  矩阵最小路径和.png %}

```java
这个题和上一个题很相似，除了第一列和第一行，如果想要到底剩下的格子的值，都等于它的上面或者左边最小的那个值然后加上它本身的值，这个题又转换为了二维数组的问题。so easy！！

import java.util.*;


public class Solution {
    /**
     * 
     * @param matrix int整型二维数组 the matrix
     * @return int整型
     */
    public int minPathSum (int[][] matrix) {
        // write code here
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] road = new int[m][n];
        road[0][0] = matrix[0][0];
        for(int i = 1; i < m; i++){
            road[i][0] = road[i-1][0] + matrix[i][0];
        }
        for(int j = 1; j < n; j++){
            road[0][j] = road[0][j-1] + matrix[0][j];
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                if(road[i-1][j] < road[i][j-1]){
                    road[i][j] = road[i-1][j] + matrix[i][j];
                }else{
                    road[i][j] = road[i][j-1] + matrix[i][j];
                }
            }
        }
        return road[m-1][n-1];
    }
}
```

# 2022-3-24

## 1、哈希-两数之和

给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。

输入：[3,2,4],6

返回值：[2,3]

说明：因为 2+4=6 ，而 2的下标为2 ， 4的下标为3 ，又因为 下标2 < 下标3 ，所以返回[2,3]

### 普通解法：循环套循环-蛮力法

```java
import java.util.*;
public class Solution {
    public int[] twoSum (int[] numbers, int target) {
        // write code here
        int[] a = new int[2];
        for(int i = 0; i < numbers.length; i++){
            if(numbers[i] > target) continue;
            a[0] = i+1;
            for(int j = i+1; j < numbers.length; j++){
                if(numbers[i] + numbers[j] == target){
                    a[1] = j+1;
                    return a;
                }
            }
        }
        return a;
    }
}
```

### 高级解法-哈希表-通过哈希遍历解

```java
通过遍历将 target-number[i] 的结果保存在map的k中，v为下标；但是前提是要先判断当前的map中是否含有了想要的结果，如果有的话就直接保存在结果数组a中，然后进行返回，否则就将 target-number[i] 的值保存在map中。

import java.util.*;
public class Solution {
    public int[] twoSum (int[] numbers, int target) {
        // write code here
        HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();
        int[] a = new int[2];
        for(int i = 0; i < numbers.length; i++){
            if(result.containsKey(numbers[i])){
                a[0] = result.get(numbers[i]);
                a[1] = i+1;
                break;
            }else{
                result.put(target - numbers[i], i+1);
            }
        }
        return a;
    }
}

```

## 2、哈希-数组中出现次数超过一半的数字

描述：给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

例如：输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。

### 哈希法

```java
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        int a = array.length%2==0? array.length/2 : array.length/2+1;
        HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();
        for(int i = 0; i < array.length; i++){
            if(result.containsKey(array[i])) {
                result.put(array[i], result.get(array[i]) + 1);
            }
            else {
                result.put(array[i], 1);
            }
            if(result.get(array[i]) >= a){
                return array[i];
            }
        }
        return 0;
    }
}
```

### 排序法

可以先将数组排序，然后可能的众数肯定在数组中间，然后判断一下。

```java
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        int a = array.length/2;
        Arrays.sort(array);
        return array[a];
    }
}
```

### 候选法-最优

就是抵消法，因为这个数必定是大于数组一半的长度，就和竞选选票差不多。

最坏情况：[ 1， 2， 1， 3， 1， 4， 1 ]

一个一个的抵消，最后剩下了一个数，这个数，必定是超过一半的数字。

```java
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        int piao = 0;
        int ren = 0;
        for(int i = 0; i < array.length; i++){
            if(piao == 0) { // 如果票是0，那就换下一个人
                ren = array[i];
                piao++; // 每个人默认票数是1，因为自己支持自己
            }
            else { // 说明这个时候他的票数肯定不是0
                if(ren == array[i]) piao++; //遇到了支持他的人
                else piao--; // 这个人不支持他
            }
        }
        return ren;
    }
}
```

## 3、哈希-数组中出现一次的两个数字

一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

### 哈希法

```java
import java.util.*;
public class Solution {
    public int[] FindNumsAppearOnce (int[] array) {
        // write code here
        HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();
        int[] a = new int[2];
        for(int i = 0; i < array.length; i++){
            if(result.containsKey(array[i])) result.remove(array[i]);
            else result.put(array[i], 1);
        }
        int j = 0;
        for(Integer i: result.keySet()){
            a[j++] = i;
        }
        return a;
    }
}
```

### 排序法

先对数组从小到大排序，然后相同的两个数肯定就在一起了，然后进行比较，如果当前数字和下一个数字一样，那么就往后跳两个，如果不一样那么就跳一个。如果当前是最后一个，那么直接就添加到a。

```java
import java.util.*;
public class Solution {
    public int[] FindNumsAppearOnce (int[] array) {
        // write code here
        Arrays.sort(array);
        int[] a = new int[2];
        int j = 0;
        for(int i = 0; i < array.length; i++){
            // 这里是重点，如果已经比到了最后一个说明这个必定是所要的结果，那么就直接添加，因为他没有后一个元素，会出现空指针异常。
            if(i + 1 == array.length || array[i] != array[i+1]){
                a[j++] = array[i];
            }else{
                i++;
            }
        }
        return a;
    }
}
```

JS代码

```js
function FindNumsAppearOnce( array ) {
    // write code here
    array.sort((a, b) => a-b);
    var res = [];
    for(let i = 0; i < array.length; i++){
        if(i + 1 == array.length || array[i] != array[i+1]){
               res.push(array[i]);
           }else{
               i++;
           }
    }
    return res;
}
module.exports = {
    FindNumsAppearOnce : FindNumsAppearOnce
};
```



### 位运算法

要用到异或，数学看不懂

```
异或(^)，两个数二进制对应位数相同为0，不同为1。
两个相等的数异或为0,0和一个数异或等于这个数。

这道题用的是a^b^b等于a。

因为有a和b不同，剩下都是两两重复的数。先把数组元素全部异或一遍，得到的数为a^b。
通过a^b来得到从右到左第一个1保留，剩下都为0的变量m。
m的这个1可以把a和b分开，剩下成对元素的分组无所谓，最后异或都会为0。
```

```java
public int[] FindNumsAppearOnce (int[] array) {
        int[] res = new int[2];
        if(array == null || array.length == 0) return res;
        //0和谁异或(^)都是该数本身
        int x = 0;
        for(int i = 0;i < array.length;i++){
            x ^= array[i];
        }
        int m = 1;
        //想要的是m左移后的那个数
        while((x & 1) != 1){
            x >>= 1;
            m <<= 1;
        }
        res[0] = res[1] = 0;
        //左移后得到的m可以把数组分为2组
        for(int i = 0;i < array.length;i++){
            //但是m和array[i]与运算结果是m本身或0
            if((array[i] & m) == m){
                res[0] ^= array[i];
            }else{
                res[1] ^= array[i];
            }
        }
        //把大的放到res[1]
        if(res[0] > res[1]){
            int temp = res[0];
            res[0] = res[1];
            res[1] = temp;
        }
        return res;
}
```

# 2022-3-25

## 1、缺失的第一个正整数

给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数

输入：[1,0,2]

返回值：3

输入：[-2,3,4,1,5]

返回值：2

输入：[4,5,6,8,9]

返回值：1

### 我的解法

```java
import java.util.*;
public class Solution {
    public int minNumberDisappeared (int[] nums) {
        // write code here
        Arrays.sort(nums);  // 先进行排序
        boolean flag = false; // 用来判断数组中是否包含 1
        for(int i = 0; i < nums.length - 1; i++){ // 遍历数组
            if(nums[i] < 0) continue;  // 如果小于0，直接下一次
            if(nums[i] == 1) flag = true;  // 如果有1了，那就标记有1
            if(nums[i] != nums[i+1] - 1 && flag == true){
                return nums[i] + 1; // 如果发现空余的正整数，并且数组中已经有1了，那么就返回这个数
            }
        } 
        // 循环完了，进行判断
        if(flag == false) { // 如果没有 1， 那就返回1
            return 1;
        }else{ // 如果有1，说明这个数组是从 1开始，并且顺序都对。eg：1，2，3，4，5。 那么就返回最后一个数+1
            return nums[nums.length-1]+1;
        }
    }
}
```

### 哈希法-1

```java
// 讲数组中出现过的元素添加到HashMap中，然后从1开始遍历【如果没有1，那么就直接返回1】，一直到数组的长度（因为数字都是连续的），如果期间存在没有的数字，就说明数组中没有该数字，直接返回；如果遍历结束了还没有返回，那就说明数组本身就是从1开始连续的，缺少的就是 nums.length + 1；

public int minNumberDisappeared (int[] nums) {
        // write code here
        if(nums.length == 0) return 1;
        HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();
        for(int i = 0; i < nums.length; i++){
            result.put(nums[i], 1);
        }
        for(int i = 1; i < nums.length; i++){
            if(!result.containsKey(i)){
                return i;
            }
        }
        return nums.length + 1;
    }
```

### 哈希法-2

```java
public int minNumberDisappeared (int[] nums) {
    HashSet<Integer> set = new HashSet<>();
    for (int i = 0; i < nums.length; i++) {
        set.add(nums[i]);
    }
    int j = 1;
    while (set.contains(j)){
        j++;
    }
    return j;
}
```

### 常规-数学

```java
import java.util.*;
public class Solution {
    public int minNumberDisappeared (int[] nums) {
        int[] arr = new int[nums.length+2];
        for(int i =0; i < nums.length; i++){
            if(nums[i]>0&&nums[i]<arr.length){
                arr[nums[i]] = i+1;
            }
        }
        int i = 1;
        while(arr[i]!=0){
            i++;
        }
        return i;
    }
}
```



## 2、三数之和

给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。

输入：[-10,0,10,20,-10,-40]

返回值：[[-10,-10,20],[-10,0,10]]



输入：[-2,0,1,1,2]

返回值：[[-2,0,2],[-2,1,1]]



输入：[0,0]

返回值：[]

### 暴力法

```java
import java.util.*;
public class Solution {
    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
        ArrayList<ArrayList<Integer>> a = new ArrayList<ArrayList<Integer>>();
        if(num.length <= 2) return a;
        Arrays.sort(num);
        int i = 0;
        int j;
        // 双重循环，和双指针法差不多
        for(; i < num.length - 2 && num[i] <= 0;){
            int k = num.length - 1;
            for(j = i + 1; j < k; ){
                if(num[i] + num[j] + num[k] > 0){
                    while(num[k] == num[k-1]) k--;
                    k--;
                }else if(num[i] + num[j] + num[k] < 0){
                    while(num[j] == num[j+1]) j++;
                    j++;
                }else{
                    ArrayList<Integer> temp = new ArrayList<Integer>();
                    temp.add(num[i]);
                    temp.add(num[j]);
                    temp.add(num[k]);
                    a.add(temp);
                    while(num[k] == num[k-1] && k > j) k--;
                    while(num[j] == num[j+1] && j < k) j++;
                    j++;
                    k--;
                }
            }
            while(num[i] == num[i+1] && num.length-i > 2) i++;
            i++;
            j = i + 1;
            k = num.length - 1;
        }
        return a;
    }
}
```

{% asset_img  三数之和-双指针法图解.png %}

### 双指针法

```java
import java.util.*;
public class Solution {
    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
        ArrayList<ArrayList<Integer>> a = new ArrayList<ArrayList<Integer>>();
        if(num.length <= 2) return a;
        Arrays.sort(num);  //  排序数组
        int i = 0;  // 当前数字
        int j = i + 1; // 左指针
        int k = num.length - 1; // 右指针
        while(num.length-i > 2 && num[i] <= 0){ 
            // 因为要留下的数最起码有三个，所以num.length-i > 2 ;如果num[i] 已经大于0了，那么后面的数相加肯定都大于0【已经排序过的数组】
            while(j < k){
                if(num[i] + num[j] + num[k] > 0){
                    while(num[k] == num[k-1]) k--;
                    k--;
                }else if(num[i] + num[j] + num[k] < 0) {
                    while(num[j] == num[j+1]) j++;
                    j++;
                }else{
                    ArrayList<Integer> temp = new ArrayList<Integer>();
                    temp.add(num[i]);
                    temp.add(num[j]);
                    temp.add(num[k]);
                    a.add(temp);
                    while(num[k] == num[k-1] && k > j) k--;
                    while(num[j] == num[j+1] && j < k) j++;
                    j++;
                    k--;
                }
            }
            while(num[i] == num[i+1] && num.length-i > 2) i++;
            i++;
            j = i + 1;
            k = num.length - 1;
        }
        return a;
    }
}
```

# 2022-3-28

## 1、二进制数-国王喝酒

```
这个题考察的是对二进制的熟悉程度。1000桶酒，只需要十个人就可以一次性找出毒酒。详解如下:
把十个人看做十位二进制数，把酒按照二进制数依次从0000000001编到1111101000(十进制的1000)，然后让编号里对应1位置的人喝这个酒桶里的酒。如第500(二进制0111110100)桶酒，让第2，3，4，5，6，8个人喝，依次喝完。从最后反馈的结果可以直接得出毒酒所在，如:第3，4，6，8，9，10个人毒发，则对应编号为11010111，即第215桶。
```

# 2022-4-18

## 1、链表-找到链表最后k个结点

输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。

如果该链表长度小于k，请返回一个长度为 0 的链表。

```js
function FindKthToTail( pHead ,  k ) {
    // write code here
    if(pHead == null || k == 0) return null;
    let node = pHead;
    for(let i = 0; i < k; i++){
        if(pHead == null) return null;
        pHead = pHead.next;
    }
    while(pHead){
        node = node.next;
        pHead = pHead.next;
    }
    return node;
}
```

## 2、链表-判断链表中是否有环

```js
/*
快慢指针: 快指针要比慢指针的速度快一步；
	1. 链表是一个没有环路的链表，那么快指针一定会走到 null，那么就直接 return false；
	2. 链表是有环路的，那么因为快指针的速度是比满指针快 1 步的，所以 当快慢指针都进入环路之后，总有一个时刻是相遇的时候，这个时候 fast == slow，就说明他们相遇了，就有环路了。
*/

function hasCycle( head ) {
    // write code here
    if(!head || !head.next) return null;
    var slow = head;
    var fast = head;
    while(fast !== null && fast.next !== null){
        fast = fast.next.next;
        slow = slow.next;
        if(fast == slow) return true;
    }
    return false;
}
```

# 2022-4-19

## 1、链表-两个链表的第一个公共结点

{% asset_img  两个链表的第一个公共结点.png %}

```js
/*
思路： 
    第一步 先把两个链表的长度都分别求出来
    第二步 把长度较长的结点先往后移动 length1 - length2 长度的距离
    【如果有公共结点，那么说明 公共结点 后面的部分都是相同的，所以说，先走length1-length2 距离。然后 如果有公共结点，两链表向后同时移动，必定会遇到】
    第三步 让两个链表同时向后移动，并且判断连个指针是否相同，如果相同，那么就返回结点值
*/

function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    if(pHead1 == null || pHead2 == null) return null;
    var temp1 = pHead1;
    var temp2 = pHead2;
    var length2 = 0;
    var length1 = 0;
    while(temp1 !== null){
        temp1 = temp1.next;
        length1++;
    }
    while(temp2 !== null){
        temp2 = temp2.next;
        length2++;
    }
    if(length1 >= length2){
        for(let i = 0; i < length1-length2; i++){
            pHead1 = pHead1.next;
        }
    }else{
        for(let i = 0; i < length2-length1; i++){
            pHead2 = pHead2.next;
        }
    }
    while(pHead1 !== null && pHead2 !== null){
        if(pHead1 == pHead2){
            return pHead1;
        }
        pHead1 = pHead1.next;
        pHead2 = pHead2.next;
    }
    return null;
}
```

```java
// 哈希解法
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    HashMap<ListNode, Integer> result = new HashMap<ListNode, Integer>();
    ListNode p1 = pHead1;
    ListNode p2 = pHead2;
    while(p1 != null){
        result.put(p1, 1);
        p1 = p1.next;
    }
    while(p2 != null){
        if(result.containsKey(p2)) {
            return p2;
        }
        p2 = p2.next;
    }
    return null;
}
```

## 2、链表-删除有序链表中重复的元素-I

删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次
例如：
给出的链表为1→1→2,返回1→2.
给出的链表为1→1→2→3→3,返回 1→2→3.

```js
// 双指针
function deleteDuplicates( head ) {
    // write code here
    if(head == null || head.next == null) return head;
    var pre = head;
    var temp = pre.val;
    var cur = pre.next;
    while(cur != null){
        if(cur.val <= temp){
            pre.next = cur.next;
            cur = cur.next;
        }else{
            pre = pre.next;
            cur = cur.next;
            temp = pre.val;
        }
    }
    return head;
}
```

# 2022-4-20

## 1、链表-删除有序链表中重复的元素-2

给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。
例如：
给出的链表为1→2→3→3→4→4→5, 返回1→2→5.
给出的链表为1→1→1→2→3, 返回2→3.

数据范围：链表长度 0≤*n*≤10000，链表中的值满足 ∣val∣≤1000

要求：空间复杂度 O(n)*O*(*n*)，时间复杂度 O(n)*O*(*n*)

进阶：空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

```js
// 双指针
/*
	思路: 为了防止，刚开始就是重复的结点【如 1-1-1-2-3】，就要直接先创建一个结点，这个结点的下一个是头结点，最后返回这个结点的下一个就好了。
	当进入循环后，只有两种情况：
	
	1、 cur的值和它下一个的值相同
	
		(1) 因为后面的 val 和 cur.val 相同，那就通过while循环直接跳，直到找到下一个的val和cur.val不一样的结点，但是要注意：当跳出循环后，当前的cur是重复 val 结点中的最后一个哦，这个也是不要的结点，所以我们再让 cur  往后跳一个 让cur = cur.next。
		
		这个时候要考虑 三 个情况
		(2) 一：如果现在的cur遍历到最后一个节点了，或者cur === null了，那么我们直接把 pre.next 指向 cur，然后 break 循环。
		(3) 二：【说明cur后面还有结点】 让cur指向他的下一个【因为现在的cur是重复结点的最后一个，不是想要的】。如果 现在的 cur的val 和 cur.next.val 还相等，那么就 continue，继续下一波的循环，不进行处理。
		(4) 三：【说明cur后面还有结点，并且cur.next.val !== cur.val】 那么当前的 cur 结点就是我们想要的结点，就进行处理【pre.next = cur; pre = pre.next; cur = cur.next】
		
	2、 cur的值和它下一个的值不相同，那么这个结点就是我们想要的，那么就直接进行处理【pre.next = cur; pre = pre.next; cur = cur.next】
	
*/

function deleteDuplicates( head ) {
    // write code here
    if(head == null || head.next == null) return head;
    var pre = new ListNode(head.val-1);
    var node = pre; // 自己创建的结点
    pre.next = head;
    var cur = pre.next;
    while(cur !== null){
        // 1、 cur的值和它下一个的值相同
        if(cur.next !== null && cur.val === cur.next.val){
            // (1) 
            while(cur.next !==null && cur.val === cur.next.val){
                cur = cur.next;
            }
            cur = cur.next;
            // (2)
            if(cur === null || cur.next == null) {
                pre.next = cur;
                break;
            }
            // (3)
            if(cur.val === cur.next.val){
                continue;
            }
        }
        // 2、 + (4) 的处理步骤
        pre.next = cur;
        cur = cur.next;
        pre = pre.next;
    }
    return node.next;
}
```

## 2、链表-判断一个链表是否为回文结构

回文结构： 121：true   123：false    1：true    12：false

就是说，这个东西，正着读和反着读都一样的

```js
/*
	思路：
	1. 通过while循环，通过快慢指针来判断这个 链表 是奇数个结点还是偶数个结点。
		如果是偶数个结点，那么最后循环结束的时候，slow是指向后半部分的开始位置。
		如果是奇数个结点，那么最后循环结束的时候，slow是指向中间结点的，需要在next一下。
	2. 循环结束，确定了 slow 的位置，然后就是 反转后半部分的链表【为了方便后边进行循环判断】。
	3. 通过循环，从 链表头部 开始和 反转后半部分的链表头部 开始进行判断，看是否相等。
*/

function isPail( head ) {
    // write code here
    if(head == null) return false;
    if(head.next == null) return true;
    var slow = head;
    var fast = head;
    // 1. 
    while(fast != null){
        slow = slow.next;
        fast = fast.next.next;
        if(fast == null){ // 偶数 -> 不用动 slow
            break;
        }
        if(fast.next == null){ // 奇数 -> 动slow
            slow = slow.next;
            break;
        }
    }
    var pre = slow; // pre就是后半部分反转后的 头指针
    slow = slow.next;
    pre.next = null;
    // 2. 开始反转后半部分
    while(slow !== null){
        var temp = slow;
        slow = slow.next;
        temp.next = pre;
        pre = temp;
    }
    // 3.
    while(pre !== null){
        if(pre.val !== head.val){
            return false;
        }
        pre = pre.next;
        head = head.next;
    }
    return true;
}
```

## 3、链表-链表内指定区间反转

将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)*O*(*n*)，空间复杂度 O(1)*O*(1)。
例如：
给出的链表为 1→2→3→4→5→NULL, m=2,n=4*m*=2,*n*=4,
返回 1→4→3→2→5→NULL

```js
/*
	首先，这道题要反转指定区间的链表的话，最终，链表被分为了三部分，首部，中间分割部分，尾部。
	那么就有思路了： 1. 先把链表遍历到 要反转的那个结点。 2. 反转链表。  3. 连接三部分。
	但是问题出现了，要考虑一种情况，如果分割的部分是从 第一个结点开始 的，那么就算我们刚开始不遍历，那么第一个位置也不行，因为我们要走到结点之前，目的是为了连接三部分，所以就要创建另一个头结点了，让这个自己创建的 头结点.next = head，然后进行操作。
	步骤：
		1. 创建自己的头结点，然后遍历到反转的前一个结点，并且记录这个结点，方便以后要连接。
		2. 反转区间链表， 记录下头结点，还有尾结点，方便连接。
		3. 记录下反转链表之后的结点，然后做最后的连接。
		
链表的顺序：  newNode(头) -> node1(第一部分的尾)  ->  pre(第二部分的头) -> node3(第二部分的尾) -> cur(第三部分的头)
*/

function reverseBetween( head ,  m ,  n ) {
    // write code here
    if(head == null || head.next == null) return head;
    // 1.
    var node1 = new ListNode(-1);
    var newNode = node1;
    node1.next = head; // node1为左边部分的尾指针
    for(let i = 1; i < m; i++){
        node1 = node1.next;
    }
    // 2.
    var pre = node1.next; // pre为中间反转段的开头【反转之后的开头】
    var node3 = pre; // node3是是pre的尾结点【反转之后的】
    var cur = pre.next; // cur最后记录的是 后面部分的结点
    pre.next = null;  
    for(var j = 0; j < n-m; j++){
        var temp = cur;
        cur = cur.next;
        temp.next = pre;
        pre = temp;
    }
    // 3.
    node1.next = pre;
    node3.next = cur;
    return newNode.next;
}
```

# 2022-4-21

## 1、链表-链表中环的入口结点

给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。

### 哈希法 1

```java
/*	HashMap
	感觉哈希表好简单啊
	思路：通过遍历，首先进行一次判断是否哈希表中已经有了当前结点【如果已经存在说明这个结点就是头环的头结点，那么就直接返回这个结点】；如果没有，就把这个几点存储在哈希表中。
*/

public ListNode EntryNodeOfLoop(ListNode pHead) {
    HashMap<ListNode, Integer> map = new HashMap<ListNode, Integer>();
    ListNode node = pHead;
    while(node != null){
        if(map.containsKey(node)){
            return node;
        }
        map.put(node, 1);
        node = node.next;
    }
    return null;
}
```



### 哈希法 2

```java
/*
	HashSet
*/

public ListNode EntryNodeOfLoop(ListNode pHead) {
        HashSet<ListNode> map = new HashSet<ListNode>();
        ListNode node = pHead;
        while(node != null){
            if(map.contains(node)){
                return node;
            }
            map.add(node);
            node = node.next;
        }
        return null;
    }
```

### 双指针

{% asset_img  链表中环的入口结点.png %}

```java
/*
相遇时,
快指针路程=a+(b+c)k+b ，k>=1 其中b+c为环的长度，k为绕环的圈数（k>=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。

慢指针路程=a+b

因为快指针走的路程是慢指针的两倍，所以：
（a+b）*2=a+(b+c)k+b

化简可得（消项，右边+c-c）：
a=(k-1)(b+c)+c 这个式子的意思是：
链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度。其中k>=1,所以k-1>=0圈。所以一个指针从相遇点出发一个指针从头结点出发速度一样，一定会在环入口相遇
*/

public ListNode EntryNodeOfLoop(ListNode pHead) {
    if(pHead == null || pHead.next == null) return null;
    ListNode slow = pHead;
    ListNode fast = pHead;
    while(true){
        fast = fast.next.next;
        slow = slow.next;
        if(fast == slow) {
            break;
        }
        if(fast == null || fast.next == null) return null;
    }
    fast = pHead;
    while(true){
        if(fast == slow) return fast;
        fast = fast.next;
        slow = slow.next;
    }
}
```

# 2022-4-25

## 1、链表-删除链表的倒数第n个节点

给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针
例如，

给出的链表为: 1→2→3→4→5, n= 2*n*=2.
删除了链表的倒数第 n 个节点之后,链表变为1→2→3→5.

```js
/*
	快慢指针
	 - 让 fast 先走n步
	 - 如果这时候，fast已经是空了，那么说明删除的是第一个节点，那么直接返回 head.next
	 - 再让 slow 和 fast 一起走，当 fast.next == null 的时候，slow.next 就是要删除的那个元素
	 - 再让 slow.next == slow.next.next 就可以了
*/

function removeNthFromEnd( head ,  n ) {
    // write code here
    var slow = head;
    var fast = head;
    for(let i = 0; i < n; i++){
        fast = fast.next;
    }
    if(fast == null) return head.next;
    while(fast.next != null){
        slow = slow.next;
        fast = fast.next;
    }
    var temp = slow.next;
    slow.next = slow.next.next;
    temp = null;
    return head;
}
```

## 2、链表-链表的奇偶重排

给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。

注意是节点的编号而非节点的数值。

题目就是说：把链表中，奇数位结点的 val  放在一起，偶数位结点的 val 放在一起，然后重新排到一起输出。

```js
function oddEvenList( head ) {
    // write code here
    var odd = new ListNode(-1);
    var even = new ListNode(-1);
    var temp1 = odd;
    var temp2 = even;
    var i = 1;
    while(head != null){
        if(i++ % 2 == 1){
            temp1.next = head;
            temp1 = temp1.next;
            head = head.next;
        }else{
            temp2.next = head;
            temp2 = temp2.next;
            head = head.next;
        }
    }
    temp2.next = null;
    temp1.next = even.next;
    return odd.next;
}
```

# 2022-4-26

## 1、链表-链表中的节点每k个一组翻转

将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表
如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样
你不能更改节点中的值，只能更改节点本身。

数据范围：  0≤*n*≤2000 ， 1≤*k*≤2000 ，链表中每个元素都满足 0≤*v**a**l*≤1000
要求空间复杂度 O(1)*O*(1)，时间复杂度 O(n)*O*(*n*)

例如：

给定的链表是 1→2→3→4→5

对于 k = 2*k*=2 , 你应该返回 2→1→4→3→5

对于 k = 3*k*=3 , 你应该返回 3→2→1→4→5

```js
/*
	采用 双指针，解题思分五步
	1. 要创建一个新的链表头结点，用来拼接链表用，然后进行 while 循环，终止条件是 链表走到了最后。
	2. 执行 for 循环，循环 k 次，如果循环了 k 次之后， fast != null || ( fast == null && i == k ) 说明整个链表刚好够分组，并且fast 已经到最后了。但是如果 在执行for 的过程中已经 fast == null 了，说明不够分组了，直接 break 出 for 循环。
	3. 如果够分组，那么就进行 反转链表，然后进行 拼接新的链表
	4. 如果不够分组，那么就直接将剩余部分拼接到新的链表上去
	5. 最后直接返回新链表的 next
*/

function reverseKGroup( head ,  k ) {
    // write code here
    if(head == null || head.next == null || k < 2) return head;
    var newhead = new ListNode(-1); // 新的链表头结点
    var node = newhead;	// 声明一个 node 指针，指向 newhead，并且操作node来改变 newhead
    var fast = head;	// 让 fast 和 slow 都指向 head，来进行循环，并且判断分组情况
    var slow = head;
    while(fast != null){  // 1.
        let i = 0;
        for(; i < k; i++){  // 2.
            if(fast == null) break;
            fast = fast.next;
        }
        var nexthead = slow; // 这里很机智，用 nexthead 来保存 反转后的那段链表的头结点
        // 3. 可以分组
        if(fast != null || (fast == null && i == k)){
            var pre = null;
            var cur = slow;
            while(slow != fast){ 	// 反转链表
                var temp = slow.next;
                cur.next = pre;
                slow = temp;
                pre = cur;
                cur = slow;
            }	// 反转结束，进行拼接
            node.next = pre; // pre 是当前 反转链表中的 头节点
            node = nexthead; // 这里也很机智，因为 上面提前保存了最后一个节点的位置，所以直接拼接
        }else{ 
            // 4. 不可以分组
            node.next = slow; // 直接让 node.next 指向 slow 【slow在这个时候就是最后剩下的不够分的链表头部】
            break;
        }
    }
    // 5. node 已经把所有 newhead 后面的结点要做的事情都搞定了，只需要返回 newhead.next 即可
    return newhead.next;
}
```

## 2、链表-链表相加(二)

假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。

给定两个这种链表，请生成代表两个整数相加值的结果链表。

输入：[9,3,7],[6,3]

返回值：{1,0,0,0}

输入：[0],[6,3

返回值：{6,3}

```js
/*
	代码冗余度太高辣！
	
	1. 反转两个链表，这样才能 从各位开始相加，创建一个新的链表，用来保存之后相加的结果信息
	2. 每次都要判断 是否两个链表都不为空，并且还要判断  进位符 是否为 1
	3. 当循环结束之后，要判断两种情况  1 - 链表1为空，  2- 链表2为空， 3-都为空，但是carry为 1
	4. 每次循环之后都进行 链表的头插，因为是从个位数开始相加的
*/

function addInList( head1 ,  head2 ) {
    // write code here
    if(head1 == null) return head2;
    if(head2 == null) return head1;
    // 1. 定义了个反转链表的方法
    var node1 = reverse(head1); // 反转之后的两个链表
    var node2 = reverse(head2);
    var newList = new ListNode(-1); // 新链表
    var carry = 0; // 进位符
    var temp = 0;  // 每次两位数 和 进位符 相加用来保存结果的
    // 2.
    while(node1 !== null && node2 !== null){
        if(node1.val + node2.val + carry >= 10) {
            temp = (node1.val + node2.val + carry) % 10; 
            carry = 1;
        }else{
            temp = node1.val + node2.val + carry;
            carry = 0;
        }
        var tempNode = new ListNode(temp);
        tempNode.next = newList.next;
        newList.next = tempNode;
        node1 = node1.next;
        node2 = node2.next;
    }
    if(node1 == null && node2 == null && carry == 1){
        var tempNode = new ListNode(1);
        tempNode.next = newList.next;
        newList.next = tempNode;
        return newList.next;
    }
    if(node1 == null){
        while(node2 !== null){
            if(node2.val + carry >= 10){
                temp = (node2.val + carry) % 10;
                carry = 1;
            }else{
                temp = node2.val + carry;
                carry = 0;
            }
            var tempNode = new ListNode(temp);
            tempNode.next = newList.next;
            newList.next = tempNode;
            node2 = node2.next;
        }
        return newList.next;
    }
    if(node2 == null){
        while(node1 !== null){
            if(node1.val + carry >= 10){
                temp = (node1.val + carry) % 10;
                carry = 1;
            }else{
                temp = node1.val + carry;
                carry = 0;
            }
            var tempNode = new ListNode(temp);
            tempNode.next = newList.next;
            newList.next = tempNode;
            node1 = node1.next;
        }
        return newList.next;
    }
    return newList.next;
}
function reverse(head){
    var pre = null;
    var cur = head;
    var temp;
    while(cur !== null){
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

优化后：

```js
/*
	好好体会代码的封装
*/

function addInList( head1 ,  head2 ) {
    // write code here
    if(head1 == null) return head2;
    if(head2 == null) return head1;
    var node1 = reverse(head1);
    var node2 = reverse(head2);
    var newList = new ListNode(-1);
    var carry = 0;
    var temp = 0;
    while(node1 !== null || node2 !== null || carry != 0){
        var v1 = node1 == null ? 0 : node1.val;
        var v2 = node2 == null ? 0 : node2.val;
        temp = (v1 + v2 + carry) % 10;
        carry = Math.floor((v1 + v2 + carry) / 10);
        
        var tempNode = new ListNode(temp);
        tempNode.next = newList.next;
        newList.next = tempNode;
        if(node1 != null) node1 = node1.next;
        if(node2 != null) node2 = node2.next;
    }
    return newList.next;
}
function reverse(head){
    var pre = null;
    var cur = head;
    var temp;
    while(cur !== null){
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```



## 3、链表-合并k个已排序的链表

合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。

输入：[{1,2,3},{4,5,6,7}]

返回值：{1,2,3,4,5,6,7}

### 两两排序

一遍做出来，超鸡动

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if(lists.length == 0 || lists == null) return null;
    var newList = lists[0];
    var len = lists.length;
    for(let i = 1; i < len; i++){
        newList = operation(newList, lists[i]);
    }
    return newList;
};
function operation(list1, list2){
    var newList = new ListNode(-999);
    var node = newList;
    while(list1 != null || list2 != null){
        if(list1 == null){
            node.next = list2;
            return newList.next;
        }
        if(list2 == null){
            node.next = list1;
            return newList.next;
        }
        if(list1.val <= list2.val){
            node.next = list1;
            node = node.next;
            list1 = list1.next;
        }else{
            node.next = list2;
            node = node.next;
            list2 = list2.next;
        }
    }
    return newList.next;
}
```

### 分治法



# 2022-4-27

## 1、最长不含重复字符的子字符串

### JS

```js
/*
	每次匹配，都判断一下是否之前保存过这个值，如果保存过，说明此次可以得到一个 max【但是不知道是不是最大的】，然后更换 下一次的 i  之后，再进行循环。
*/

function lengthOfLongestSubstring( s ) {
    // write code here
    var temp = {};
    var strArr = s.slice(0);
    var max = 0;
    var index = 0;
    for(let i = 0; i < strArr.length; i++){
        if(temp[strArr[i]] == null){
            temp[strArr[i]] = i;
            index++;
            max = index > max ? index : max;
        }else{
            i = temp[strArr[i]];
            index = 0;
            temp = {};
        }
    }
    return max;
}
```

```js
// 上面方法的优化

var lengthOfLongestSubstring = function(s) {
    var temp = []; // 存储字符最后一次出现的位置
    var res = 0; // 存储最后的结果
    var start = 0; // 比较开始的位置
    for(let i = 0; i < s.length; i++){
        if(temp[s.charAt(i)] == undefined || temp[s.charAt(i)] < start){
            temp[s.charAt(i)] = i;
            res = Math.max(res, i-start+1);
        }else{
            res = Math.max(res, i - start);
            start = Math.max(start, temp[s.charAt(i)] + 1);
            temp[s.charAt(i)] = i;
        }
    }
    return res;
};
```

### JS的Map

```js
var lengthOfLongestSubstring = function(s) {
    if(s.length === 0)return 0;
    var max = 0;
    let len = s.length;
    for(let i = 0; i < len; i++){
        var map = new Map();
        while(s[i]){
            if(map.get(s[i]) == undefined){
                map.set(s[i], i++);
            }else{
                i = map.get(s[i]);
                break;
            }
        }
        max = Math.max(max, map.size);
        map.clear();
    }
    return max;
};

```

## 2、寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

```js
// 要点是：要注意下标，是从0开始的

var findMedianSortedArrays = function(nums1, nums2) {
    var nums = [...nums1, ...nums2];
    nums.sort((a, b) => a-b);
    var len = nums.length;
    if(len % 2 == 0){
        return ((nums[Math.floor(len/2)] + (nums[Math.floor(len/2-1)]))/2).toFixed(5);
    }else{
        return nums[Math.floor(len/2)];
    }
};
```

# 2022-4-28

## 1、回文数字

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

```js
var isPalindrome = function(x) {
    var numArr = (x.toString()).slice('');
    var l = 0;
    var h = numArr.length-1;
    while(l < h){
        if(numArr[l] == numArr[h]) {
            l++;
            h--;
            continue;
        }
        return false;
    }
    return true;
};
```

## 2、盛最多水的容器

这道题比较难理解题目，但是题目理解了之后，还是很好做的。



给定一个长度为`n`的整数数组 `height`。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

{% asset_img  盛最多水的容器.png %}

```js
/*
	首先，这道题的难点在于，题目不好理解，什么时候能接到的水，才是最多的，就是什么时候矩形面积最大？
	这里，矩形的面积，等于 = （左右两边中，较短的那条边） * 两边之间的距离。
	而且，面积的大小取决于较短的那条边，每次循环的移动的时候，移动较短的那条边，虽然下面的距离变短了，但是 有可能面积会更大。绝对不能移动较长的边，这样只会让面积越来越小。
	所以，直接采用双指针的方法，让一条边指向 左边，一条边指向 右边
*/

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    var res = 0;
    var l = 0;
    var h = height.length-1;
    while(l < h){
        res = Math.max(res, Math.min(height[l], height[h]) * (h - l));
        if(height[l] < height[h]){
            l++;
        }else{
            h--;
        }
    }
    return res;
};
```

## 3、整数转罗马数字

哈哈哈哈哈哈，直接暴力

罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给你一个整数，将其转为罗马数字。

**示例 1:**

```
输入: num = 3
输出: "III"
```

**示例 2:**

```
输入: num = 4
输出: "IV"
```

**示例 3:**

```
输入: num = 9
输出: "IX"
```

**示例 4:**

```
输入: num = 58
输出: "LVIII"
解释: L = 50, V = 5, III = 3.
```

**示例 5:**

```
输入: num = 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

 ```js
/*
	简单粗暴，从上到下，顺序不能乱
*/

/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function(num) {
    var str = '';
    var temp = 0;
    if(num >= 1000){
        temp = Math.floor(num / 1000);
        num = Math.floor(num%1000);
        for(let i = 0; i < temp; i++){
            str = str + 'M';
        }
    }
    if(num >= 900){
        num = Math.floor(num%900);
        str = str + 'CM';
    }
    if(num >= 500){
        num = Math.floor(num%500);
        str = str + 'D';
    }
    if(num >= 400){
        num = Math.floor(num%400);
        str = str + 'CD';
    }
    if(num >= 100){
        temp = Math.floor(num / 100);
        num = Math.floor(num%100);
        for(let i = 0; i < temp; i++){
            str = str + 'C';
        }
    }
    if(num >= 90){
        num = Math.floor(num%90);
        str = str + 'XC';
    }
    if(num >= 50){
        num = Math.floor(num%50);
        str = str + 'L';
    }
    if(num >= 40){
        num = Math.floor(num%40);
        str = str + 'XL';
    }
    if(num >= 10){
        temp = Math.floor(num / 10);
        num = Math.floor(num%10);
        for(let i = 0; i < temp; i++){
            str = str + 'X';
        }
    }
    if(num == 9){
        num = Math.floor(num%9);
        str = str + 'IX';
        return str;
    }
    if(num >= 5){
        num = Math.floor(num%5);
        str = str + 'V';
    }
    if(num == 4){
        num = Math.floor(num%4);
        str = str + 'IV';
        return str;
    }
    // 最后  0 < num < 4
    if(num > 0){
        for(let i = 0; i < num; i++){
            str = str + 'I';
        }
        return str;
    }
    return str;
};
 ```

优化之后的做法：

```js
var intToRoman = function(num) {
    var str = '';
    var value = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    var strArr = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'];
    for(let i = 0; i < value.length; i++){
        if(num < value[i]) continue;
        while(num >= value[i]){
            num -= value[i];
            str = str + strArr[i];
        }
    }
    return str;
};
```

## 4、罗马数字转整数

和上一个题目相反

**示例 1:**

```
输入: s = "III"
输出: 3
```

**示例 2:**

```
输入: s = "IV"
输出: 4
```

**示例 3:**

```
输入: s = "IX"
输出: 9
```

**示例 4:**

```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

**示例 5:**

```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```



**比较笨**

```js
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
    var obj = {
        M: 1000,
        CM: 900,
        D: 500,
        CD: 400,
        C: 100,
        XC: 90,
        L: 50,
        XL: 40,
        X: 10,
        IX: 9,
        V: 5,
        IV: 4,
        I: 1
    }
    var num = 0;
    var strArr = s.split('');
    var i = 0;
    var str = strArr[i];
    while(str != null){
        if(obj[str]){
            if(obj[`${str}${strArr[i+1]}`]){
                num += obj[`${str}${strArr[i+1]}`];
                ++i;
                str = strArr[++i];
            }else{
                num += obj[str];
                str = strArr[++i];
            }
        }
    }
    return num;
};
```



**优化后**

```js
/*
	因为正常情况下，如果不存在组合的罗马数字，都是 MDCLXVI，这个时候，前面的字母是 > 后面的字母 的值的，而如果 存在组合的情况 比如 CM，这个时候，先让 num -= C，然后让 num += M；然后 num = num + 900，是和之前 CM 代表的值是一样的。
	所以当遇到这种组合情况，先减去 前面的数字，然后再加上后面的数字就OK
*/
var romanToInt = function(s) {
    var obj = {
        M: 1000,
        D: 500,
        C: 100,
        L: 50,
        X: 10,
        V: 5,
        I: 1
    }
    var num = 0;
    for(let i = 0; i < s.length; i++){
        if(obj[s[i]] < obj[s[i+1]]){
            num -= obj[s[i]];
        }else{
            num += obj[s[i]];
        }
    }
    return num;
};
```

# 2022-4-29

## 1、最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**

```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

**暴力解法**

```js
var longestCommonPrefix = function(strs) {
    var str = ''; // 结果字符串
    let testStr = strs[0]; // 用strs中第一个字符串来比较
    for(let i = 0; i < strs[0].length; i++){
        let temp1 = testStr[i];	// 每次都拿到 比较字符串 的第一个字符
        for(let j = 1; j < strs.length; j++){
            let temp2 = strs[j]; // 每次遍历后面的每个字符串的第 i个字符
            if(temp2[i] == null) return str;  // 如果不存在，直接返回str
            if(temp1 === temp2[i]){
                continue;	// 如果相等，那么就继续下一轮，知道所有的字符串的 第i个字符 都相等
            }else{
                return str;
            }
        }
        str = str + temp1;
    }
    return str;
};
```

**改进之后的暴力法**

```js
var longestCommonPrefix = function(strs) {
    var str = strs[0];
    var len = strs[0].length;
    for(let i = 1; i < strs.length; i++){  // 从前往后
        while(true){
            if(strs[i].slice(0, len) == str.slice(0, len)){
                break;
            }else{
                len--;
            }
        }
    }
    return str.slice(0, len);
};
```

**改进暴力之后继续优化代码[ 相比上一个---比较慢 ]**

```js
var longestCommonPrefix = function(strs) {
    var str = strs[0];
    var len = strs[0].length;
    var i = 0;
    while(true){
        if(strs[i] == null) return str.slice(0, len);
        if(strs[i].slice(0, len) == str.slice(0, len)){
            i++;
        }else{
            len--;
        }
    }
};
```

## 2、三数之和

双指针

**要注意的是，排序的时候，要注意，sort的条件(a, b) => a-b**

一个固定的指针 指向 nums[i]

然后移动 nums[l] 和 nums[h]，来判断什么时候 和 为 0

```js
var threeSum = function(nums) {
    var res = [];
    nums.sort((a, b) => a-b);
    for(let i = 0; i < nums.length-2 && nums[i] <= 0; i++){
        let l = i+1;
        let h = nums.length-1;
        while(l < h){
            var temp = nums[i] + nums[l] + nums[h]
            if( temp > 0 ){
                while(nums[h] == nums[h-1]) h--;
                h--;
            }else if(temp < 0){
                while(nums[l] == nums[l+1]) l++;
                l++;
            }else{
                res.push([nums[i], nums[l], nums[h]]);
                while(nums[h] == nums[h-1]) h--;
                while(nums[l] == nums[l+1]) l++;
                h--;l++;
            }
        }
        while(nums[i] === nums[i+1]) i++;
    }
    return res;
};
```



## 3、最接近的三数之和

给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target`。请你从 `nums` 中选出三个整数，使它们的和与 `target` 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

 

**示例 1：**

```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

**示例 2：**

```
输入：nums = [0,0,0], target = 1
输出：0
```



**双指针 JS**

 ```js
var threeSumClosest = function(nums, target) {
    var res = 999;
    nums.sort((a, b) => a-b);
    for(let i = 0; i < nums.length-2; i++){
        let l = i+1;
        let h = nums.length-1;
        while(l < h){
            var temp = nums[i] + nums[l] + nums[h]
            if( temp > target ){
                while(nums[h] == nums[h-1]) h--;
                h--;
            }else if(temp < target){
                while(nums[l] == nums[l+1]) l++;
                l++;
            }else{
                return target;
            }
            if(Math.abs(res - target) > Math.abs(temp - target)){
                res = temp;
            }
        }
        while(nums.length-2 && nums[i] === nums[i+1]) i++;
    }
    return res;
};
 ```

# 2022-6-4

## 1.电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母

{% asset_img  电话号码组合.png %}

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]

输入：digits = ""
输出：[]

输入：digits = "2"
输出：["a","b","c"]

```js
// 思路: 先判断输入的这个数字字符串是0位,1位,还是更多位,如果更多,那就先用两位进行运算,然后再进行剩余的运算,每次都拿出来一位来进行运算,最后返回结果即可
const info = {
    "0": "", // 0
    "1": "", // 1
    "2": "abc", // 2
    "3": "def", // 3
    "4": "ghi", // 4
    "5": "jkl", // 5
    "6": "mno", // 6
    "7": "pqrs", // 7
    "8": "tuv", // 8
    "9": "wxyz" // 9
};
var letterCombinations = function(digits) {
    if(digits.length === 0) {
        return [];
    }
    if(digits.length === 1) {
        return info[digits].split("");
    }
    let i = 0;
    var res = info[digits[i]].split("");
    var temp = info[digits[++i]].split("");
    while(digits[i]){
        res = op(res, temp);
        i++;
        if(info[digits[i]]) {
            temp = info[digits[i]].split("");
        }
    }
    return res;
};

function op (res, temp) {
    var all = [];
    for(let x = 0; x < res.length; x++) {
        for(let y = 0; y < temp.length; y++){
            all.push(res[x]+temp[y]);
        }
    }
    return all;
}

```



## 2.四数之和

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。

输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]

```js
// 思路:用三层循环,先让最外面的循环,当做一个标兵,不然他动,然后动里面的那层循环,然后这层循环里面,采用双指针来做,相当于是暴力算法的优化方法!
var fourSum = function(nums, target) {
    nums.sort((a, b) => a-b);
    let res = [];
    let max = nums.length-1;
    let i = 0;
    let num1 = nums[i];
    while(i < nums.length - 3) {
        let i2 = i + 1;
        let l = i2 + 1;
        let h = max;
        while(i2 < nums.length - 2){
            let num2 = nums[i2];
            let low = nums[l];
            let high = nums[h];
            while(l < h) {
                if(num1 + num2 + low + high == target) {
                    res.push([num1, num2, low, high]);
                    while(nums[l] == low) {l++;}
                    while(nums[h] == high) {h--;}
                    low = nums[l];
                    high = nums[h];
                } else if (num1 + num2 + low + high < target) {
                    while(nums[l] == low) {l++;}
                    low = nums[l];
                } else if (num1 + num2 + low + high > target) {
                    while(nums[h] == high) {h--;}
                    high = nums[h];
                }
            }
            while(nums[i2] == num2) {i2++;}
            l = i2 + 1;
            h = max;
        }
        while(num1 == nums[i]) {i++;}
        num1 = nums[i];
    }
    return res;
};
```

# 2022-6-6

## 1.有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

输入：s = "()"
输出：true

输入：s = "()[]{}"
输出：true

输入：s = "(]"
输出：false

输入：s = "([)]"
输出：false

输入：s = "{[]}"
输出：true

```js
// 思路: 创建一个用来保存目前应该匹配的括号的数组来模拟一个栈,然后通过循环,每次遍历
var isValid = function(s) {
    var arr = s.split('');
    if(arr.length % 2 !== 0) return false;
    var res = [];
    res.push(arr[0]);
    for(let i = 1; i < arr.length; i++) {
        let cur = res.length - 1;
        if(res[cur] == '(' && arr[i] == ')') {
            res.pop();
            continue;
        } else if (res[cur] == '[' && arr[i] == ']') {
            res.pop();
            continue;
        } else if (res[cur] == '{' && arr[i] == '}') {
            res.pop();
            continue;
        } else {
            res.push(arr[i]);
        }
    }
    if(res.length) {
        return false;
    } else {
        return true;
    }
};
```

## 2.最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

输入：nums = [1]
输出：1

输入：nums = [5,4,-1,7,8]
输出：23

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
// 思路: 动态规划,你想知道到当前值的时候前面最大的子序列和,你必须知道前一个的最大是多少
// 方法一:创建一个空的结果集数据用来存放 当到达前面的数字的时候 前面数字的最大的值.然后用Math.max来判断最大的值,最后返回
// 方法二是优化了之后的,不要数组,因为每次只需要前一个数字的最大值,所以用一个number来保存前面的result的最大值
var maxSubArray = function(nums) {
    if(nums.length === 0) {return;}
    if(nums.length === 1) {return nums[0];}
    
    // 方法一:
    // var res = [];
    // res[0] = nums[0];
    // var max = res[0];
    // for(let i = 1; i < nums.length; i++) {
    //     res[i] = Math.max(res[i-1] + nums[i], nums[i]);
    //     max = Math.max(res[i], max);
    // }
    // return max;

    // 方法二:
    let temp = nums[0];
    let max = temp;
    for(let i = 1; i < nums.length; i++) {
        temp = Math.max(temp + nums[i], nums[i]);
        max = Math.max(max, temp);
    }
    return max;

};
```

## 3.螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

```js
// 思路:关键是处理好在里面的第三个和第四个循环的地方,因为这两个地方遇到特殊情况的时候会影响结果(最后剩下一排,或者最后剩下一列),所以要加上一个额外的判断条件才行
var spiralOrder = function(matrix) {
    if(matrix.length == 0) return [];
    var bottom = matrix.length - 1; // 行数
    var right = matrix[0].length - 1; // 列数
    let top = 0;
    let left = 0;
    var res = [];
    while(top < matrix.length/2 && left < matrix[0].length/2) {
        for(let i = left; i <= right; i++) {
            res.push(matrix[top][i]);
        }
        for(let i = top+1; i <= bottom; i++) {
            res.push(matrix[i][right]);
        }
        for(let i = right-1; i >= left && top !== bottom; i--) {
            res.push(matrix[bottom][i]);
        }
        for(let i = bottom-1; i > top && left !== right; i--) {
            res.push(matrix[i][left]);
        }
        left++;
        right--;
        bottom--;
        top++;
    }
    return res;
};
```

## 4.跳跃游戏

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

```js
/**
 思路:
 	想象你是那个在格子上行走的小人，格子里面的数字代表“能量”，你需要“能量”才能继续行走。
	每次走到一个格子的时候，你检查现在格子里面的“能量”和你自己拥有的“能量”哪个更大，取更大的“能量”！ 如果你有更多的能量，你就可以走的更远啦！~
 */
var canJump = function(nums) {
    if(nums.length <= 1) return true; // 如果这个数组的长度<=0,那么就不用移动了
    var cur = nums[0]; // 当前的能量
    if(cur <= 0) { // 如果刚开始的能量就为0
        return false;
    }
    for(let i = 1; i < nums.length-1; i++) { // 从第二个位置开始计算
        cur--; // 让能量 -1 
        cur = Math.max(cur, nums[i]); // 判断移动到这个位置,如何能量会更多(保持自己还是拿到这个格子的能量)
        if(cur == 0) { // 如果现在的能量是0,那么就移动不了了
            return false;
        }
    }
    return true;
};
```



# 2022-6-7

## 1.合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

```js
// 思路: 先把给的数组进行排序,按照第一个值的升序进行排序,所以现在只需要比较前面的最大值,和后面的最小值,这样就能知道他们之间的关系
var merge = function(intervals) {
    intervals.sort((a, b) => a[0] - b[0]);
    let l = intervals[0][0];
    let h = intervals[0][1];
    let res = [];
    for(let i = 1; i < intervals.length; i++) {
        if(intervals[i][0] <= h) {
            h = Math.max(intervals[i][1], h);
        } else {
            res.push([l, h]);
            l = intervals[i][0];
            h = intervals[i][1];
        }
    }
    res.push([l, h]);
    return res;
};
```

## 2.插入区间

给你一个 无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

```js
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]

输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。

输入：intervals = [], newInterval = [5,7]
输出：[[5,7]]

输入：intervals = [[1,5]], newInterval = [2,3]
输出：[[1,5]]

输入：intervals = [[1,5]], newInterval = [2,7]
输出：[[1,7]]
```

```js
// 思路: 这道题的意思无非是在上一个题中,原数组中新添加了一个元素,问你区间范围而已
var insert = function(intervals, newInterval) {
    intervals.push([...newInterval]);
    intervals.sort((a, b) => a[0] - b[0]);
    let res = [];
    let l = intervals[0][0];
    let h = intervals[0][1];
    for(let i = 1; i < intervals.length; i++) {
        if(intervals[i][0] <= h) {
            h = Math.max(intervals[i][1], h);
        } else {
            res.push([l, h]);
            l = intervals[i][0];
            h = intervals[i][1];
        }
    }
    res.push([l, h]);
    return res;
};
```

## 3.最后一个单词的长度

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

```
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为5。

输入：s = "   fly me   to   the moon  "
输出：4
解释：最后一个单词是“moon”，长度为4。

输入：s = "luffy is still joyboy"
输出：6
解释：最后一个单词是长度为6的“joyboy”。
```

```js
// 思路: 去掉首尾的空格,获取最后一个空格的索引,截取这个空格后的子串,返回长度
var lengthOfLastWord = function(s) {
    s = s.trim();
    let last = s.lastIndexOf(" ");
    return s.substr(++last).length;
};
```

## 4.螺旋矩阵 II

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/length-of-last-word
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

输入：n = 1
输出：[[1]]
```

```js
// 思路:关键是处理好在里面的第三个和第四个循环的地方,因为这两个地方遇到特殊情况的时候会影响结果(最后剩下一排,或者最后剩下一列),所以要加上一个额外的判断条件才行
// 和	 螺旋矩阵I	 	一样的思路
var generateMatrix = function(n) {
    let res = [];
    for(var i=0;i<n;i++){   
        res[i]=new Array();  //再声明二维 
        for(var j=0;j<n;j++){   //二维长度为3
            res[i][j]=0;   // 赋值，每个数组元素的值为i+j
        }
    }
    let top = 0;
    let bottom = n - 1;
    let left = 0;
    let right = n - 1;
    let count = 1;
    while(left < n/2) {
        for(let i = left; i <= right; i++) {
            res[top][i] = count++;
        }
        for(let i = top+1; i <= bottom; i++) {
            res[i][right] = count++;
        }
        // 防止最后就剩下一排的情况
        for(let i = right-1; i >= left && top !== bottom; i--) {
            res[bottom][i] = count++;
        }
        // 防止最后就剩下一列的情况
        for(let i = bottom-1; i > top && left !== right; i--) {
            res[i][left] = count++;
        }
        top++;
        bottom--;
        left++;
        right--;
    }
    return res;
};
```

## 5.旋转链表

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]

输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

```js
// 和 删除链表倒数第K个结点差不多
var rotateRight = function(head, k) {
    if(head == null || k == 0) return head;
    let len = 1;
    // 记录头指针
    let node = head;
    // 存储尾指针
    let last = null;
    // 快慢指针
    let slow = head;
    let fast = head;
    while(node.next !== null) {
        len++;
        node = node.next;
    }
    last = node;
    k = k % len;
    // 如果k为链表长度的倍数,说明不需要操作链表
    if(k == 0) return head;
    for(let i = 0; i < k; i++) {
        fast = fast.next;
    }
    while(fast.next !== null) {
        fast = fast.next;
        slow = slow.next;
    }
    // 新链表的头指针
    let newHead = slow.next;
    slow.next = null;
    last.next = head;
    return newHead;

};
```

**优化**

```js
var rotateRight = function(head, k) {
    if(head == null || k == 0) return head;
    // 链表长度
    let len = 1;
    // 记录头指针
    let node = head;
    // 存储尾指针
    let last = null;
    let temp = head;
    while(node.next !== null) {
        len++;
        node = node.next;
    }
    last = node;
    k = k % len;
    // 如果k为链表长度的倍数,说明不需要操作链表
    if(k == 0) return head;
	// 这里直接来进行移动指针,因为我即知道长度又知道倒数第几个
    for(let i = 0; i < len-k-1; i++) {
        temp = temp.next;
    }
    // 新链表的头指针
    let newHead = temp.next;
    temp.next = null;
    last.next = head;
    return newHead;

};
```

# 常见括号问题

## 1. 有效括号问题

### 1、题目描述

数字 n 代表生成括号的对数，设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

### 2、解题思路

1、分析题意，考虑递归中的回溯二叉树，有效的括号即左右括号要对应
1.1、每放置一个左括号，便可以放置一个右括号，并且在左括号数量小于 n 时依然可以放置左括号（形成二叉树，在满足左括号数量小于 n 的情况下把新的节点当做根节点）
2、定义一个数组容器用来存放符合条件的括号组合，定义一个空字符串用来写入括号
3、定义函数（涉及递归不可用匿名函数）
3.1、左括号数量不大于 n 时可以添加左括号
3.2、左括号数量大于右括号时可以添加右括号
4、当左右括号数量和达到 2*n 时把字符串push()进容器数组
5、返回容器数组，即为所求所有可能的并且 有效的 括号组合

###  3 代码

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
    let res = [];
    var drow = (cur, left, right) => {
        if (cur.length === 2 * n) {
			res.push(cur);
			return;
        }
		if (left < n) {
			drow(cur + "(", left + 1, right)
        }
		if (left > right) {
			drow(cur + ")", left, right + 1);
        }
    };
    drow("", 0, 0);
    return res;
};

```

## 2. 括号匹配问题

### 题目

'{([])}', '{}()[]', '([{]])', '[}'` 括号匹配检查，匹配返回 true，反之 false

### 代码

```js
let [str, str1, str2, str3] = ['{([])}', '{}()[]', '([{]])', '[}']

function check(str) {
    let stack = [], flag = true

    str.split('').map(res => {
        if (res === '{' || res === '(' || res === '[') {
            stack.push(res)
            return
        }

        let concatStr = stack[stack.length - 1] + res

        if (concatStr === '[]' || concatStr === '{}' || concatStr === '()') {
            stack.pop()
        } else {
            flag = false
        }
    })

    return flag
}

console.log(check(str0)); // true
console.log(check(str1)); // true
console.log(check(str2)); // false
console.log(check(str3)); // false
```

















